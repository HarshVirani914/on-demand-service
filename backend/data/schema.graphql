type Address {
  address: String

  """Reads and enables pagination through a set of `Availability`."""
  availabilitiesByBookingAddressIdAndAvailabilityId(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: AvailabilityCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: AvailabilityFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `Availability`."""
    orderBy: [AvailabilitiesOrderBy!] = [PRIMARY_KEY_ASC]
  ): AddressAvailabilitiesByBookingAddressIdAndAvailabilityIdManyToManyConnection!

  """Reads and enables pagination through a set of `Booking`."""
  bookings(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: BookingCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: BookingFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `Booking`."""
    orderBy: [BookingsOrderBy!] = [PRIMARY_KEY_ASC]
  ): BookingsConnection!

  """Reads a single `Company` that is related to this `Address`."""
  company: Company
  companyId: UUID
  contactNumber: String
  createdAt: Datetime!
  id: UUID!
  isPrimary: Boolean!

  """Reads and enables pagination through a set of `Service`."""
  servicesByBookingAddressIdAndServiceId(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ServiceCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: ServiceFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `Service`."""
    orderBy: [ServicesOrderBy!] = [PRIMARY_KEY_ASC]
  ): AddressServicesByBookingAddressIdAndServiceIdManyToManyConnection!
  updatedAt: Datetime!

  """Reads a single `User` that is related to this `Address`."""
  user: User
  userId: UUID!

  """Reads and enables pagination through a set of `User`."""
  usersByBookingAddressIdAndUserId(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: UserCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: UserFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `User`."""
    orderBy: [UsersOrderBy!] = [PRIMARY_KEY_ASC]
  ): AddressUsersByBookingAddressIdAndUserIdManyToManyConnection!
}

"""The fields on `address` to look up the row to connect."""
input AddressAddressesCompanyIdKeyConnect {
  companyId: UUID!
}

"""The fields on `address` to look up the row to delete."""
input AddressAddressesCompanyIdKeyDelete {
  companyId: UUID!
}

"""The fields on `address` to look up the row to connect."""
input AddressAddressesPkeyConnect {
  id: UUID!
}

"""The fields on `address` to look up the row to delete."""
input AddressAddressesPkeyDelete {
  id: UUID!
}

"""
A connection to a list of `Availability` values, with data from `Booking`.
"""
type AddressAvailabilitiesByBookingAddressIdAndAvailabilityIdManyToManyConnection {
  """
  A list of edges which contains the `Availability`, info from the `Booking`, and the cursor to aid in pagination.
  """
  edges: [AddressAvailabilitiesByBookingAddressIdAndAvailabilityIdManyToManyEdge!]!

  """A list of `Availability` objects."""
  nodes: [Availability!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Availability` you could get from the connection."""
  totalCount: Int!
}

"""A `Availability` edge in the connection, with data from `Booking`."""
type AddressAvailabilitiesByBookingAddressIdAndAvailabilityIdManyToManyEdge {
  """Reads and enables pagination through a set of `Booking`."""
  bookings(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: BookingCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: BookingFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `Booking`."""
    orderBy: [BookingsOrderBy!] = [PRIMARY_KEY_ASC]
  ): BookingsConnection!

  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Availability` at the end of the edge."""
  node: Availability!
}

"""
A condition to be used against `Address` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input AddressCondition {
  """Checks for equality with the object’s `companyId` field."""
  companyId: UUID

  """Checks for equality with the object’s `id` field."""
  id: UUID

  """Checks for equality with the object’s `userId` field."""
  userId: UUID
}

"""
A filter to be used against `Address` object types. All fields are combined with a logical ‘and.’
"""
input AddressFilter {
  """Checks for all expressions in this list."""
  and: [AddressFilter!]

  """Filter by the object’s `bookings` relation."""
  bookings: AddressToManyBookingFilter

  """Some related `bookings` exist."""
  bookingsExist: Boolean

  """Filter by the object’s `company` relation."""
  company: CompanyFilter

  """A related `company` exists."""
  companyExists: Boolean

  """Filter by the object’s `companyId` field."""
  companyId: UUIDFilter

  """Filter by the object’s `id` field."""
  id: UUIDFilter

  """Negates the expression."""
  not: AddressFilter

  """Checks for any expressions in this list."""
  or: [AddressFilter!]

  """Filter by the object’s `user` relation."""
  user: UserFilter

  """Filter by the object’s `userId` field."""
  userId: UUIDFilter
}

"""An input for mutations affecting `Address`"""
input AddressInput {
  address: String
  bookingsUsingId: BookingsAddressIdFkeyInverseInput
  companyId: UUID
  companyToCompanyId: AddressesCompanyIdFkeyInput
  contactNumber: String
  isPrimary: Boolean
  userId: UUID
  userToUserId: AddressesUserIdFkeyInput
}

"""The fields on `address` to look up the row to update."""
input AddressOnAddressForAddressesCompanyIdFkeyUsingAddressesCompanyIdKeyUpdate {
  companyId: UUID!

  """
  An object where the defined keys will be set on the `address` being updated.
  """
  patch: updateAddressOnAddressForAddressesCompanyIdFkeyPatch!
}

"""The fields on `address` to look up the row to update."""
input AddressOnAddressForAddressesCompanyIdFkeyUsingAddressesPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `address` being updated.
  """
  patch: updateAddressOnAddressForAddressesCompanyIdFkeyPatch!
}

"""The fields on `address` to look up the row to update."""
input AddressOnAddressForAddressesUserIdFkeyUsingAddressesCompanyIdKeyUpdate {
  companyId: UUID!

  """
  An object where the defined keys will be set on the `address` being updated.
  """
  patch: updateAddressOnAddressForAddressesUserIdFkeyPatch!
}

"""The fields on `address` to look up the row to update."""
input AddressOnAddressForAddressesUserIdFkeyUsingAddressesPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `address` being updated.
  """
  patch: updateAddressOnAddressForAddressesUserIdFkeyPatch!
}

"""The fields on `address` to look up the row to update."""
input AddressOnBookingForBookingsAddressIdFkeyUsingAddressesCompanyIdKeyUpdate {
  companyId: UUID!

  """
  An object where the defined keys will be set on the `address` being updated.
  """
  patch: updateAddressOnBookingForBookingsAddressIdFkeyPatch!
}

"""The fields on `address` to look up the row to update."""
input AddressOnBookingForBookingsAddressIdFkeyUsingAddressesPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `address` being updated.
  """
  patch: updateAddressOnBookingForBookingsAddressIdFkeyPatch!
}

"""
Represents an update to a `Address`. Fields that are set will be updated.
"""
input AddressPatch {
  address: String
  bookingsUsingId: BookingsAddressIdFkeyInverseInput
  companyId: UUID
  companyToCompanyId: AddressesCompanyIdFkeyInput
  contactNumber: String
  isPrimary: Boolean
  userId: UUID
  userToUserId: AddressesUserIdFkeyInput
}

"""A connection to a list of `Service` values, with data from `Booking`."""
type AddressServicesByBookingAddressIdAndServiceIdManyToManyConnection {
  """
  A list of edges which contains the `Service`, info from the `Booking`, and the cursor to aid in pagination.
  """
  edges: [AddressServicesByBookingAddressIdAndServiceIdManyToManyEdge!]!

  """A list of `Service` objects."""
  nodes: [Service!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Service` you could get from the connection."""
  totalCount: Int!
}

"""A `Service` edge in the connection, with data from `Booking`."""
type AddressServicesByBookingAddressIdAndServiceIdManyToManyEdge {
  """Reads and enables pagination through a set of `Booking`."""
  bookings(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: BookingCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: BookingFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `Booking`."""
    orderBy: [BookingsOrderBy!] = [PRIMARY_KEY_ASC]
  ): BookingsConnection!

  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Service` at the end of the edge."""
  node: Service!
}

"""
A filter to be used against many `Booking` object types. All fields are combined with a logical ‘and.’
"""
input AddressToManyBookingFilter {
  """
  Every related `Booking` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: BookingFilter

  """
  No related `Booking` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: BookingFilter

  """
  Some related `Booking` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: BookingFilter
}

"""A connection to a list of `User` values, with data from `Booking`."""
type AddressUsersByBookingAddressIdAndUserIdManyToManyConnection {
  """
  A list of edges which contains the `User`, info from the `Booking`, and the cursor to aid in pagination.
  """
  edges: [AddressUsersByBookingAddressIdAndUserIdManyToManyEdge!]!

  """A list of `User` objects."""
  nodes: [User!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `User` you could get from the connection."""
  totalCount: Int!
}

"""A `User` edge in the connection, with data from `Booking`."""
type AddressUsersByBookingAddressIdAndUserIdManyToManyEdge {
  """Reads and enables pagination through a set of `Booking`."""
  bookings(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: BookingCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: BookingFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `Booking`."""
    orderBy: [BookingsOrderBy!] = [PRIMARY_KEY_ASC]
  ): BookingsConnection!

  """A cursor for use in pagination."""
  cursor: Cursor

  """The `User` at the end of the edge."""
  node: User!
}

"""The `address` to be created by this mutation."""
input AddressesCompanyIdFkeyAddressesCreateInput {
  address: String
  bookingsUsingId: BookingsAddressIdFkeyInverseInput
  companyToCompanyId: AddressesCompanyIdFkeyInput
  contactNumber: String
  isPrimary: Boolean
  userId: UUID
  userToUserId: AddressesUserIdFkeyInput
}

"""The `company` to be created by this mutation."""
input AddressesCompanyIdFkeyCompaniesCreateInput {
  addressUsingId: AddressesCompanyIdFkeyInverseInput
  availabilityUsingId: AvailabilitiesCompanyIdFkeyInverseInput
  companyCategoryUsingId: CompanyCategoriesCompanyIdFkeyInverseInput
  description: String
  isVerified: Boolean
  name: String!
  servicesUsingId: ServicesCompanyIdFkeyInverseInput
  userId: UUID
  userToUserId: CompaniesUserIdFkeyInput
}

"""
Input for the nested mutation of `company` in the `AddressInput` mutation.
"""
input AddressesCompanyIdFkeyInput {
  """The primary key(s) for `company` for the far side of the relationship."""
  connectById: CompanyCompaniesPkeyConnect

  """The primary key(s) for `company` for the far side of the relationship."""
  connectByUserId: CompanyCompaniesUserIdUniqueConnect

  """
  A `CompanyInput` object that will be created and connected to this object.
  """
  create: AddressesCompanyIdFkeyCompaniesCreateInput

  """The primary key(s) for `company` for the far side of the relationship."""
  deleteById: CompanyCompaniesPkeyDelete

  """The primary key(s) for `company` for the far side of the relationship."""
  deleteByUserId: CompanyCompaniesUserIdUniqueDelete

  """
  The primary key(s) and patch data for `company` for the far side of the relationship.
  """
  updateById: CompanyOnAddressForAddressesCompanyIdFkeyUsingCompaniesPkeyUpdate

  """
  The primary key(s) and patch data for `company` for the far side of the relationship.
  """
  updateByUserId: CompanyOnAddressForAddressesCompanyIdFkeyUsingCompaniesUserIdUniqueUpdate
}

"""
Input for the nested mutation of `address` in the `CompanyInput` mutation.
"""
input AddressesCompanyIdFkeyInverseInput {
  """The primary key(s) for `address` for the far side of the relationship."""
  connectByCompanyId: AddressAddressesCompanyIdKeyConnect

  """The primary key(s) for `address` for the far side of the relationship."""
  connectById: AddressAddressesPkeyConnect

  """
  A `AddressInput` object that will be created and connected to this object.
  """
  create: [AddressesCompanyIdFkeyAddressesCreateInput!]

  """The primary key(s) for `address` for the far side of the relationship."""
  deleteByCompanyId: AddressAddressesCompanyIdKeyDelete

  """The primary key(s) for `address` for the far side of the relationship."""
  deleteById: AddressAddressesPkeyDelete

  """
  Flag indicating whether all other `address` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) and patch data for `address` for the far side of the relationship.
  """
  updateByCompanyId: AddressOnAddressForAddressesCompanyIdFkeyUsingAddressesCompanyIdKeyUpdate

  """
  The primary key(s) and patch data for `address` for the far side of the relationship.
  """
  updateById: AddressOnAddressForAddressesCompanyIdFkeyUsingAddressesPkeyUpdate
}

"""A connection to a list of `Address` values."""
type AddressesConnection {
  """
  A list of edges which contains the `Address` and cursor to aid in pagination.
  """
  edges: [AddressesEdge!]!

  """A list of `Address` objects."""
  nodes: [Address!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Address` you could get from the connection."""
  totalCount: Int!
}

"""A `Address` edge in the connection."""
type AddressesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Address` at the end of the edge."""
  node: Address!
}

"""Methods to use when ordering `Address`."""
enum AddressesOrderBy {
  COMPANY_ID_ASC
  COMPANY_ID_DESC
  ID_ASC
  ID_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  USER_ID_ASC
  USER_ID_DESC
}

"""The `address` to be created by this mutation."""
input AddressesUserIdFkeyAddressesCreateInput {
  address: String
  bookingsUsingId: BookingsAddressIdFkeyInverseInput
  companyId: UUID
  companyToCompanyId: AddressesCompanyIdFkeyInput
  contactNumber: String
  isPrimary: Boolean
  userToUserId: AddressesUserIdFkeyInput
}

"""
Input for the nested mutation of `user` in the `AddressInput` mutation.
"""
input AddressesUserIdFkeyInput {
  """The primary key(s) for `user` for the far side of the relationship."""
  connectById: UserUsersPkeyConnect

  """
  A `UserInput` object that will be created and connected to this object.
  """
  create: AddressesUserIdFkeyUsersCreateInput

  """The primary key(s) for `user` for the far side of the relationship."""
  deleteById: UserUsersPkeyDelete

  """
  The primary key(s) and patch data for `user` for the far side of the relationship.
  """
  updateById: UserOnAddressForAddressesUserIdFkeyUsingUsersPkeyUpdate
}

"""
Input for the nested mutation of `address` in the `UserInput` mutation.
"""
input AddressesUserIdFkeyInverseInput {
  """The primary key(s) for `address` for the far side of the relationship."""
  connectByCompanyId: [AddressAddressesCompanyIdKeyConnect!]

  """The primary key(s) for `address` for the far side of the relationship."""
  connectById: [AddressAddressesPkeyConnect!]

  """
  A `AddressInput` object that will be created and connected to this object.
  """
  create: [AddressesUserIdFkeyAddressesCreateInput!]

  """The primary key(s) for `address` for the far side of the relationship."""
  deleteByCompanyId: [AddressAddressesCompanyIdKeyDelete!]

  """The primary key(s) for `address` for the far side of the relationship."""
  deleteById: [AddressAddressesPkeyDelete!]

  """
  Flag indicating whether all other `address` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) and patch data for `address` for the far side of the relationship.
  """
  updateByCompanyId: [AddressOnAddressForAddressesUserIdFkeyUsingAddressesCompanyIdKeyUpdate!]

  """
  The primary key(s) and patch data for `address` for the far side of the relationship.
  """
  updateById: [AddressOnAddressForAddressesUserIdFkeyUsingAddressesPkeyUpdate!]
}

"""The `user` to be created by this mutation."""
input AddressesUserIdFkeyUsersCreateInput {
  addressesUsingId: AddressesUserIdFkeyInverseInput
  bookingsUsingId: BookingsUserIdFkeyInverseInput
  companyUsingId: CompaniesUserIdFkeyInverseInput
  email: String!
  isAdmin: Boolean
  isVerified: Boolean
  name: String
  password: String
  type: String
}

"""The `availability` to be created by this mutation."""
input AvailabilitiesCompanyIdFkeyAvailabilitiesCreateInput {
  bookingsUsingId: BookingsAvailabilityIdFkeyInverseInput
  companyToCompanyId: AvailabilitiesCompanyIdFkeyInput
  endTime: Time!
  startTime: Time!
}

"""The `company` to be created by this mutation."""
input AvailabilitiesCompanyIdFkeyCompaniesCreateInput {
  addressUsingId: AddressesCompanyIdFkeyInverseInput
  availabilityUsingId: AvailabilitiesCompanyIdFkeyInverseInput
  companyCategoryUsingId: CompanyCategoriesCompanyIdFkeyInverseInput
  description: String
  isVerified: Boolean
  name: String!
  servicesUsingId: ServicesCompanyIdFkeyInverseInput
  userId: UUID
  userToUserId: CompaniesUserIdFkeyInput
}

"""
Input for the nested mutation of `company` in the `AvailabilityInput` mutation.
"""
input AvailabilitiesCompanyIdFkeyInput {
  """The primary key(s) for `company` for the far side of the relationship."""
  connectById: CompanyCompaniesPkeyConnect

  """The primary key(s) for `company` for the far side of the relationship."""
  connectByUserId: CompanyCompaniesUserIdUniqueConnect

  """
  A `CompanyInput` object that will be created and connected to this object.
  """
  create: AvailabilitiesCompanyIdFkeyCompaniesCreateInput

  """The primary key(s) for `company` for the far side of the relationship."""
  deleteById: CompanyCompaniesPkeyDelete

  """The primary key(s) for `company` for the far side of the relationship."""
  deleteByUserId: CompanyCompaniesUserIdUniqueDelete

  """
  The primary key(s) and patch data for `company` for the far side of the relationship.
  """
  updateById: CompanyOnAvailabilityForAvailabilitiesCompanyIdFkeyUsingCompaniesPkeyUpdate

  """
  The primary key(s) and patch data for `company` for the far side of the relationship.
  """
  updateByUserId: CompanyOnAvailabilityForAvailabilitiesCompanyIdFkeyUsingCompaniesUserIdUniqueUpdate
}

"""
Input for the nested mutation of `availability` in the `CompanyInput` mutation.
"""
input AvailabilitiesCompanyIdFkeyInverseInput {
  """
  The primary key(s) for `availability` for the far side of the relationship.
  """
  connectByCompanyId: AvailabilityAvailabilitiesCompanyIdUniqueConnect

  """
  The primary key(s) for `availability` for the far side of the relationship.
  """
  connectById: AvailabilityAvailabilitiesPkeyConnect

  """
  A `AvailabilityInput` object that will be created and connected to this object.
  """
  create: [AvailabilitiesCompanyIdFkeyAvailabilitiesCreateInput!]

  """
  The primary key(s) for `availability` for the far side of the relationship.
  """
  deleteByCompanyId: AvailabilityAvailabilitiesCompanyIdUniqueDelete

  """
  The primary key(s) for `availability` for the far side of the relationship.
  """
  deleteById: AvailabilityAvailabilitiesPkeyDelete

  """
  Flag indicating whether all other `availability` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) and patch data for `availability` for the far side of the relationship.
  """
  updateByCompanyId: AvailabilityOnAvailabilityForAvailabilitiesCompanyIdFkeyUsingAvailabilitiesCompanyIdUniqueUpdate

  """
  The primary key(s) and patch data for `availability` for the far side of the relationship.
  """
  updateById: AvailabilityOnAvailabilityForAvailabilitiesCompanyIdFkeyUsingAvailabilitiesPkeyUpdate
}

"""A connection to a list of `Availability` values."""
type AvailabilitiesConnection {
  """
  A list of edges which contains the `Availability` and cursor to aid in pagination.
  """
  edges: [AvailabilitiesEdge!]!

  """A list of `Availability` objects."""
  nodes: [Availability!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Availability` you could get from the connection."""
  totalCount: Int!
}

"""A `Availability` edge in the connection."""
type AvailabilitiesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Availability` at the end of the edge."""
  node: Availability!
}

"""Methods to use when ordering `Availability`."""
enum AvailabilitiesOrderBy {
  COMPANY_ID_ASC
  COMPANY_ID_DESC
  ID_ASC
  ID_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

type Availability {
  """Reads and enables pagination through a set of `Address`."""
  addressesByBookingAvailabilityIdAndAddressId(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: AddressCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: AddressFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `Address`."""
    orderBy: [AddressesOrderBy!] = [PRIMARY_KEY_ASC]
  ): AvailabilityAddressesByBookingAvailabilityIdAndAddressIdManyToManyConnection!

  """Reads and enables pagination through a set of `Booking`."""
  bookings(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: BookingCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: BookingFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `Booking`."""
    orderBy: [BookingsOrderBy!] = [PRIMARY_KEY_ASC]
  ): BookingsConnection!

  """Reads a single `Company` that is related to this `Availability`."""
  company: Company
  companyId: UUID!
  createdAt: Datetime!
  endTime: Time!
  id: UUID!

  """Reads and enables pagination through a set of `Service`."""
  servicesByBookingAvailabilityIdAndServiceId(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ServiceCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: ServiceFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `Service`."""
    orderBy: [ServicesOrderBy!] = [PRIMARY_KEY_ASC]
  ): AvailabilityServicesByBookingAvailabilityIdAndServiceIdManyToManyConnection!
  startTime: Time!

  """Reads and enables pagination through a set of `User`."""
  usersByBookingAvailabilityIdAndUserId(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: UserCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: UserFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `User`."""
    orderBy: [UsersOrderBy!] = [PRIMARY_KEY_ASC]
  ): AvailabilityUsersByBookingAvailabilityIdAndUserIdManyToManyConnection!
}

"""A connection to a list of `Address` values, with data from `Booking`."""
type AvailabilityAddressesByBookingAvailabilityIdAndAddressIdManyToManyConnection {
  """
  A list of edges which contains the `Address`, info from the `Booking`, and the cursor to aid in pagination.
  """
  edges: [AvailabilityAddressesByBookingAvailabilityIdAndAddressIdManyToManyEdge!]!

  """A list of `Address` objects."""
  nodes: [Address!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Address` you could get from the connection."""
  totalCount: Int!
}

"""A `Address` edge in the connection, with data from `Booking`."""
type AvailabilityAddressesByBookingAvailabilityIdAndAddressIdManyToManyEdge {
  """Reads and enables pagination through a set of `Booking`."""
  bookings(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: BookingCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: BookingFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `Booking`."""
    orderBy: [BookingsOrderBy!] = [PRIMARY_KEY_ASC]
  ): BookingsConnection!

  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Address` at the end of the edge."""
  node: Address!
}

"""The fields on `availability` to look up the row to connect."""
input AvailabilityAvailabilitiesCompanyIdUniqueConnect {
  companyId: UUID!
}

"""The fields on `availability` to look up the row to delete."""
input AvailabilityAvailabilitiesCompanyIdUniqueDelete {
  companyId: UUID!
}

"""The fields on `availability` to look up the row to connect."""
input AvailabilityAvailabilitiesPkeyConnect {
  id: UUID!
}

"""The fields on `availability` to look up the row to delete."""
input AvailabilityAvailabilitiesPkeyDelete {
  id: UUID!
}

"""
A condition to be used against `Availability` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input AvailabilityCondition {
  """Checks for equality with the object’s `companyId` field."""
  companyId: UUID

  """Checks for equality with the object’s `id` field."""
  id: UUID
}

"""
A filter to be used against `Availability` object types. All fields are combined with a logical ‘and.’
"""
input AvailabilityFilter {
  """Checks for all expressions in this list."""
  and: [AvailabilityFilter!]

  """Filter by the object’s `bookings` relation."""
  bookings: AvailabilityToManyBookingFilter

  """Some related `bookings` exist."""
  bookingsExist: Boolean

  """Filter by the object’s `company` relation."""
  company: CompanyFilter

  """Filter by the object’s `companyId` field."""
  companyId: UUIDFilter

  """Filter by the object’s `id` field."""
  id: UUIDFilter

  """Negates the expression."""
  not: AvailabilityFilter

  """Checks for any expressions in this list."""
  or: [AvailabilityFilter!]
}

"""An input for mutations affecting `Availability`"""
input AvailabilityInput {
  bookingsUsingId: BookingsAvailabilityIdFkeyInverseInput
  companyId: UUID
  companyToCompanyId: AvailabilitiesCompanyIdFkeyInput
  endTime: Time!
  startTime: Time!
}

"""The fields on `availability` to look up the row to update."""
input AvailabilityOnAvailabilityForAvailabilitiesCompanyIdFkeyUsingAvailabilitiesCompanyIdUniqueUpdate {
  companyId: UUID!

  """
  An object where the defined keys will be set on the `availability` being updated.
  """
  patch: updateAvailabilityOnAvailabilityForAvailabilitiesCompanyIdFkeyPatch!
}

"""The fields on `availability` to look up the row to update."""
input AvailabilityOnAvailabilityForAvailabilitiesCompanyIdFkeyUsingAvailabilitiesPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `availability` being updated.
  """
  patch: updateAvailabilityOnAvailabilityForAvailabilitiesCompanyIdFkeyPatch!
}

"""The fields on `availability` to look up the row to update."""
input AvailabilityOnBookingForBookingsAvailabilityIdFkeyUsingAvailabilitiesCompanyIdUniqueUpdate {
  companyId: UUID!

  """
  An object where the defined keys will be set on the `availability` being updated.
  """
  patch: updateAvailabilityOnBookingForBookingsAvailabilityIdFkeyPatch!
}

"""The fields on `availability` to look up the row to update."""
input AvailabilityOnBookingForBookingsAvailabilityIdFkeyUsingAvailabilitiesPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `availability` being updated.
  """
  patch: updateAvailabilityOnBookingForBookingsAvailabilityIdFkeyPatch!
}

"""
Represents an update to a `Availability`. Fields that are set will be updated.
"""
input AvailabilityPatch {
  bookingsUsingId: BookingsAvailabilityIdFkeyInverseInput
  companyId: UUID
  companyToCompanyId: AvailabilitiesCompanyIdFkeyInput
  endTime: Time
  startTime: Time
}

"""A connection to a list of `Service` values, with data from `Booking`."""
type AvailabilityServicesByBookingAvailabilityIdAndServiceIdManyToManyConnection {
  """
  A list of edges which contains the `Service`, info from the `Booking`, and the cursor to aid in pagination.
  """
  edges: [AvailabilityServicesByBookingAvailabilityIdAndServiceIdManyToManyEdge!]!

  """A list of `Service` objects."""
  nodes: [Service!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Service` you could get from the connection."""
  totalCount: Int!
}

"""A `Service` edge in the connection, with data from `Booking`."""
type AvailabilityServicesByBookingAvailabilityIdAndServiceIdManyToManyEdge {
  """Reads and enables pagination through a set of `Booking`."""
  bookings(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: BookingCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: BookingFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `Booking`."""
    orderBy: [BookingsOrderBy!] = [PRIMARY_KEY_ASC]
  ): BookingsConnection!

  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Service` at the end of the edge."""
  node: Service!
}

"""
A filter to be used against many `Booking` object types. All fields are combined with a logical ‘and.’
"""
input AvailabilityToManyBookingFilter {
  """
  Every related `Booking` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: BookingFilter

  """
  No related `Booking` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: BookingFilter

  """
  Some related `Booking` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: BookingFilter
}

"""A connection to a list of `User` values, with data from `Booking`."""
type AvailabilityUsersByBookingAvailabilityIdAndUserIdManyToManyConnection {
  """
  A list of edges which contains the `User`, info from the `Booking`, and the cursor to aid in pagination.
  """
  edges: [AvailabilityUsersByBookingAvailabilityIdAndUserIdManyToManyEdge!]!

  """A list of `User` objects."""
  nodes: [User!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `User` you could get from the connection."""
  totalCount: Int!
}

"""A `User` edge in the connection, with data from `Booking`."""
type AvailabilityUsersByBookingAvailabilityIdAndUserIdManyToManyEdge {
  """Reads and enables pagination through a set of `Booking`."""
  bookings(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: BookingCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: BookingFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `Booking`."""
    orderBy: [BookingsOrderBy!] = [PRIMARY_KEY_ASC]
  ): BookingsConnection!

  """A cursor for use in pagination."""
  cursor: Cursor

  """The `User` at the end of the edge."""
  node: User!
}

type Booking {
  """Reads a single `Address` that is related to this `Booking`."""
  address: Address
  addressId: UUID!

  """Reads a single `Availability` that is related to this `Booking`."""
  availability: Availability
  availabilityId: UUID!
  createdAt: Datetime!
  id: UUID!

  """Reads a single `Service` that is related to this `Booking`."""
  service: Service
  serviceId: UUID!
  status: String!
  updatedAt: Datetime!

  """Reads a single `User` that is related to this `Booking`."""
  user: User
  userId: UUID!
}

"""The fields on `booking` to look up the row to connect."""
input BookingBookingsPkeyConnect {
  id: UUID!
}

"""The fields on `booking` to look up the row to delete."""
input BookingBookingsPkeyDelete {
  id: UUID!
}

"""
A condition to be used against `Booking` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input BookingCondition {
  """Checks for equality with the object’s `addressId` field."""
  addressId: UUID

  """Checks for equality with the object’s `availabilityId` field."""
  availabilityId: UUID

  """Checks for equality with the object’s `id` field."""
  id: UUID

  """Checks for equality with the object’s `serviceId` field."""
  serviceId: UUID

  """Checks for equality with the object’s `userId` field."""
  userId: UUID
}

"""
A filter to be used against `Booking` object types. All fields are combined with a logical ‘and.’
"""
input BookingFilter {
  """Filter by the object’s `address` relation."""
  address: AddressFilter

  """Filter by the object’s `addressId` field."""
  addressId: UUIDFilter

  """Checks for all expressions in this list."""
  and: [BookingFilter!]

  """Filter by the object’s `availability` relation."""
  availability: AvailabilityFilter

  """Filter by the object’s `availabilityId` field."""
  availabilityId: UUIDFilter

  """Filter by the object’s `id` field."""
  id: UUIDFilter

  """Negates the expression."""
  not: BookingFilter

  """Checks for any expressions in this list."""
  or: [BookingFilter!]

  """Filter by the object’s `service` relation."""
  service: ServiceFilter

  """Filter by the object’s `serviceId` field."""
  serviceId: UUIDFilter

  """Filter by the object’s `user` relation."""
  user: UserFilter

  """Filter by the object’s `userId` field."""
  userId: UUIDFilter
}

"""An input for mutations affecting `Booking`"""
input BookingInput {
  addressId: UUID
  addressToAddressId: BookingsAddressIdFkeyInput
  availabilityId: UUID
  availabilityToAvailabilityId: BookingsAvailabilityIdFkeyInput
  serviceId: UUID
  serviceToServiceId: BookingsServiceIdFkeyInput
  userId: UUID
  userToUserId: BookingsUserIdFkeyInput
}

"""The fields on `booking` to look up the row to update."""
input BookingOnBookingForBookingsAddressIdFkeyUsingBookingsPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `booking` being updated.
  """
  patch: updateBookingOnBookingForBookingsAddressIdFkeyPatch!
}

"""The fields on `booking` to look up the row to update."""
input BookingOnBookingForBookingsAvailabilityIdFkeyUsingBookingsPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `booking` being updated.
  """
  patch: updateBookingOnBookingForBookingsAvailabilityIdFkeyPatch!
}

"""The fields on `booking` to look up the row to update."""
input BookingOnBookingForBookingsServiceIdFkeyUsingBookingsPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `booking` being updated.
  """
  patch: updateBookingOnBookingForBookingsServiceIdFkeyPatch!
}

"""The fields on `booking` to look up the row to update."""
input BookingOnBookingForBookingsUserIdFkeyUsingBookingsPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `booking` being updated.
  """
  patch: updateBookingOnBookingForBookingsUserIdFkeyPatch!
}

"""
Represents an update to a `Booking`. Fields that are set will be updated.
"""
input BookingPatch {
  addressId: UUID
  addressToAddressId: BookingsAddressIdFkeyInput
  availabilityId: UUID
  availabilityToAvailabilityId: BookingsAvailabilityIdFkeyInput
  serviceId: UUID
  serviceToServiceId: BookingsServiceIdFkeyInput
  status: String
  userId: UUID
  userToUserId: BookingsUserIdFkeyInput
}

"""The `address` to be created by this mutation."""
input BookingsAddressIdFkeyAddressesCreateInput {
  address: String
  bookingsUsingId: BookingsAddressIdFkeyInverseInput
  companyId: UUID
  companyToCompanyId: AddressesCompanyIdFkeyInput
  contactNumber: String
  isPrimary: Boolean
  userId: UUID
  userToUserId: AddressesUserIdFkeyInput
}

"""The `booking` to be created by this mutation."""
input BookingsAddressIdFkeyBookingsCreateInput {
  addressToAddressId: BookingsAddressIdFkeyInput
  availabilityId: UUID
  availabilityToAvailabilityId: BookingsAvailabilityIdFkeyInput
  serviceId: UUID
  serviceToServiceId: BookingsServiceIdFkeyInput
  userId: UUID
  userToUserId: BookingsUserIdFkeyInput
}

"""
Input for the nested mutation of `address` in the `BookingInput` mutation.
"""
input BookingsAddressIdFkeyInput {
  """The primary key(s) for `address` for the far side of the relationship."""
  connectByCompanyId: AddressAddressesCompanyIdKeyConnect

  """The primary key(s) for `address` for the far side of the relationship."""
  connectById: AddressAddressesPkeyConnect

  """
  A `AddressInput` object that will be created and connected to this object.
  """
  create: BookingsAddressIdFkeyAddressesCreateInput

  """The primary key(s) for `address` for the far side of the relationship."""
  deleteByCompanyId: AddressAddressesCompanyIdKeyDelete

  """The primary key(s) for `address` for the far side of the relationship."""
  deleteById: AddressAddressesPkeyDelete

  """
  The primary key(s) and patch data for `address` for the far side of the relationship.
  """
  updateByCompanyId: AddressOnBookingForBookingsAddressIdFkeyUsingAddressesCompanyIdKeyUpdate

  """
  The primary key(s) and patch data for `address` for the far side of the relationship.
  """
  updateById: AddressOnBookingForBookingsAddressIdFkeyUsingAddressesPkeyUpdate
}

"""
Input for the nested mutation of `booking` in the `AddressInput` mutation.
"""
input BookingsAddressIdFkeyInverseInput {
  """The primary key(s) for `booking` for the far side of the relationship."""
  connectById: [BookingBookingsPkeyConnect!]

  """
  A `BookingInput` object that will be created and connected to this object.
  """
  create: [BookingsAddressIdFkeyBookingsCreateInput!]

  """The primary key(s) for `booking` for the far side of the relationship."""
  deleteById: [BookingBookingsPkeyDelete!]

  """
  Flag indicating whether all other `booking` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) and patch data for `booking` for the far side of the relationship.
  """
  updateById: [BookingOnBookingForBookingsAddressIdFkeyUsingBookingsPkeyUpdate!]
}

"""The `availability` to be created by this mutation."""
input BookingsAvailabilityIdFkeyAvailabilitiesCreateInput {
  bookingsUsingId: BookingsAvailabilityIdFkeyInverseInput
  companyId: UUID
  companyToCompanyId: AvailabilitiesCompanyIdFkeyInput
  endTime: Time!
  startTime: Time!
}

"""The `booking` to be created by this mutation."""
input BookingsAvailabilityIdFkeyBookingsCreateInput {
  addressId: UUID
  addressToAddressId: BookingsAddressIdFkeyInput
  availabilityToAvailabilityId: BookingsAvailabilityIdFkeyInput
  serviceId: UUID
  serviceToServiceId: BookingsServiceIdFkeyInput
  userId: UUID
  userToUserId: BookingsUserIdFkeyInput
}

"""
Input for the nested mutation of `availability` in the `BookingInput` mutation.
"""
input BookingsAvailabilityIdFkeyInput {
  """
  The primary key(s) for `availability` for the far side of the relationship.
  """
  connectByCompanyId: AvailabilityAvailabilitiesCompanyIdUniqueConnect

  """
  The primary key(s) for `availability` for the far side of the relationship.
  """
  connectById: AvailabilityAvailabilitiesPkeyConnect

  """
  A `AvailabilityInput` object that will be created and connected to this object.
  """
  create: BookingsAvailabilityIdFkeyAvailabilitiesCreateInput

  """
  The primary key(s) for `availability` for the far side of the relationship.
  """
  deleteByCompanyId: AvailabilityAvailabilitiesCompanyIdUniqueDelete

  """
  The primary key(s) for `availability` for the far side of the relationship.
  """
  deleteById: AvailabilityAvailabilitiesPkeyDelete

  """
  The primary key(s) and patch data for `availability` for the far side of the relationship.
  """
  updateByCompanyId: AvailabilityOnBookingForBookingsAvailabilityIdFkeyUsingAvailabilitiesCompanyIdUniqueUpdate

  """
  The primary key(s) and patch data for `availability` for the far side of the relationship.
  """
  updateById: AvailabilityOnBookingForBookingsAvailabilityIdFkeyUsingAvailabilitiesPkeyUpdate
}

"""
Input for the nested mutation of `booking` in the `AvailabilityInput` mutation.
"""
input BookingsAvailabilityIdFkeyInverseInput {
  """The primary key(s) for `booking` for the far side of the relationship."""
  connectById: [BookingBookingsPkeyConnect!]

  """
  A `BookingInput` object that will be created and connected to this object.
  """
  create: [BookingsAvailabilityIdFkeyBookingsCreateInput!]

  """The primary key(s) for `booking` for the far side of the relationship."""
  deleteById: [BookingBookingsPkeyDelete!]

  """
  Flag indicating whether all other `booking` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) and patch data for `booking` for the far side of the relationship.
  """
  updateById: [BookingOnBookingForBookingsAvailabilityIdFkeyUsingBookingsPkeyUpdate!]
}

"""A connection to a list of `Booking` values."""
type BookingsConnection {
  """
  A list of edges which contains the `Booking` and cursor to aid in pagination.
  """
  edges: [BookingsEdge!]!

  """A list of `Booking` objects."""
  nodes: [Booking!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Booking` you could get from the connection."""
  totalCount: Int!
}

"""A `Booking` edge in the connection."""
type BookingsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Booking` at the end of the edge."""
  node: Booking!
}

"""Methods to use when ordering `Booking`."""
enum BookingsOrderBy {
  ADDRESS_ID_ASC
  ADDRESS_ID_DESC
  AVAILABILITY_ID_ASC
  AVAILABILITY_ID_DESC
  ID_ASC
  ID_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  SERVICE_ID_ASC
  SERVICE_ID_DESC
  USER_ID_ASC
  USER_ID_DESC
}

"""The `booking` to be created by this mutation."""
input BookingsServiceIdFkeyBookingsCreateInput {
  addressId: UUID
  addressToAddressId: BookingsAddressIdFkeyInput
  availabilityId: UUID
  availabilityToAvailabilityId: BookingsAvailabilityIdFkeyInput
  serviceToServiceId: BookingsServiceIdFkeyInput
  userId: UUID
  userToUserId: BookingsUserIdFkeyInput
}

"""
Input for the nested mutation of `service` in the `BookingInput` mutation.
"""
input BookingsServiceIdFkeyInput {
  """The primary key(s) for `service` for the far side of the relationship."""
  connectById: ServiceServicesPkeyConnect

  """
  A `ServiceInput` object that will be created and connected to this object.
  """
  create: BookingsServiceIdFkeyServicesCreateInput

  """The primary key(s) for `service` for the far side of the relationship."""
  deleteById: ServiceServicesPkeyDelete

  """
  The primary key(s) and patch data for `service` for the far side of the relationship.
  """
  updateById: ServiceOnBookingForBookingsServiceIdFkeyUsingServicesPkeyUpdate
}

"""
Input for the nested mutation of `booking` in the `ServiceInput` mutation.
"""
input BookingsServiceIdFkeyInverseInput {
  """The primary key(s) for `booking` for the far side of the relationship."""
  connectById: [BookingBookingsPkeyConnect!]

  """
  A `BookingInput` object that will be created and connected to this object.
  """
  create: [BookingsServiceIdFkeyBookingsCreateInput!]

  """The primary key(s) for `booking` for the far side of the relationship."""
  deleteById: [BookingBookingsPkeyDelete!]

  """
  Flag indicating whether all other `booking` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) and patch data for `booking` for the far side of the relationship.
  """
  updateById: [BookingOnBookingForBookingsServiceIdFkeyUsingBookingsPkeyUpdate!]
}

"""The `service` to be created by this mutation."""
input BookingsServiceIdFkeyServicesCreateInput {
  bookingsUsingId: BookingsServiceIdFkeyInverseInput
  categoryId: UUID
  categoryToCategoryId: ServicesCategoryIdFkeyInput
  companyId: UUID
  companyToCompanyId: ServicesCompanyIdFkeyInput
  description: String!
  name: String!
  price: Int!
}

"""The `booking` to be created by this mutation."""
input BookingsUserIdFkeyBookingsCreateInput {
  addressId: UUID
  addressToAddressId: BookingsAddressIdFkeyInput
  availabilityId: UUID
  availabilityToAvailabilityId: BookingsAvailabilityIdFkeyInput
  serviceId: UUID
  serviceToServiceId: BookingsServiceIdFkeyInput
  userToUserId: BookingsUserIdFkeyInput
}

"""
Input for the nested mutation of `user` in the `BookingInput` mutation.
"""
input BookingsUserIdFkeyInput {
  """The primary key(s) for `user` for the far side of the relationship."""
  connectById: UserUsersPkeyConnect

  """
  A `UserInput` object that will be created and connected to this object.
  """
  create: BookingsUserIdFkeyUsersCreateInput

  """The primary key(s) for `user` for the far side of the relationship."""
  deleteById: UserUsersPkeyDelete

  """
  The primary key(s) and patch data for `user` for the far side of the relationship.
  """
  updateById: UserOnBookingForBookingsUserIdFkeyUsingUsersPkeyUpdate
}

"""
Input for the nested mutation of `booking` in the `UserInput` mutation.
"""
input BookingsUserIdFkeyInverseInput {
  """The primary key(s) for `booking` for the far side of the relationship."""
  connectById: [BookingBookingsPkeyConnect!]

  """
  A `BookingInput` object that will be created and connected to this object.
  """
  create: [BookingsUserIdFkeyBookingsCreateInput!]

  """The primary key(s) for `booking` for the far side of the relationship."""
  deleteById: [BookingBookingsPkeyDelete!]

  """
  Flag indicating whether all other `booking` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) and patch data for `booking` for the far side of the relationship.
  """
  updateById: [BookingOnBookingForBookingsUserIdFkeyUsingBookingsPkeyUpdate!]
}

"""The `user` to be created by this mutation."""
input BookingsUserIdFkeyUsersCreateInput {
  addressesUsingId: AddressesUserIdFkeyInverseInput
  bookingsUsingId: BookingsUserIdFkeyInverseInput
  companyUsingId: CompaniesUserIdFkeyInverseInput
  email: String!
  isAdmin: Boolean
  isVerified: Boolean
  name: String
  password: String
  type: String
}

"""A connection to a list of `Category` values."""
type CategoriesConnection {
  """
  A list of edges which contains the `Category` and cursor to aid in pagination.
  """
  edges: [CategoriesEdge!]!

  """A list of `Category` objects."""
  nodes: [Category!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Category` you could get from the connection."""
  totalCount: Int!
}

"""A `Category` edge in the connection."""
type CategoriesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Category` at the end of the edge."""
  node: Category!
}

"""Methods to use when ordering `Category`."""
enum CategoriesOrderBy {
  ID_ASC
  ID_DESC
  NAME_ASC
  NAME_DESC
  NATURAL
  PARENT_ID_ASC
  PARENT_ID_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  SLUG_ASC
  SLUG_DESC
}

"""The `category` to be created by this mutation."""
input CategoriesParentIdFkeyCategoriesCreateInput {
  categoryToParentId: CategoriesParentIdFkeyInput
  companyCategoriesUsingId: CompanyCategoriesCategoryIdFkeyInverseInput
  description: String!
  name: String!
  servicesUsingId: ServicesCategoryIdFkeyInverseInput
  slug: String!
}

"""
Input for the nested mutation of `category` in the `CategoryInput` mutation.
"""
input CategoriesParentIdFkeyInput {
  """
  The primary key(s) for `category` for the far side of the relationship.
  """
  connectById: CategoryCategoriesPkeyConnect

  """
  The primary key(s) for `category` for the far side of the relationship.
  """
  connectByName: CategoryCategoriesNameKeyConnect

  """
  The primary key(s) for `category` for the far side of the relationship.
  """
  connectBySlug: CategoryCategoriesSlugKeyConnect

  """
  A `CategoryInput` object that will be created and connected to this object.
  """
  create: CategoriesParentIdFkeyCategoriesCreateInput

  """
  The primary key(s) for `category` for the far side of the relationship.
  """
  deleteById: CategoryCategoriesPkeyDelete

  """
  The primary key(s) for `category` for the far side of the relationship.
  """
  deleteByName: CategoryCategoriesNameKeyDelete

  """
  The primary key(s) for `category` for the far side of the relationship.
  """
  deleteBySlug: CategoryCategoriesSlugKeyDelete

  """
  The primary key(s) and patch data for `category` for the far side of the relationship.
  """
  updateById: CategoryOnCategoryForCategoriesParentIdFkeyUsingCategoriesPkeyUpdate

  """
  The primary key(s) and patch data for `category` for the far side of the relationship.
  """
  updateByName: CategoryOnCategoryForCategoriesParentIdFkeyUsingCategoriesNameKeyUpdate

  """
  The primary key(s) and patch data for `category` for the far side of the relationship.
  """
  updateBySlug: CategoryOnCategoryForCategoriesParentIdFkeyUsingCategoriesSlugKeyUpdate
}

type Category {
  """Reads and enables pagination through a set of `Category`."""
  childCategories(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CategoryCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: CategoryFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `Category`."""
    orderBy: [CategoriesOrderBy!] = [PRIMARY_KEY_ASC]
  ): CategoriesConnection!

  """Reads and enables pagination through a set of `Company`."""
  companiesByServiceCategoryIdAndCompanyId(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CompanyCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: CompanyFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `Company`."""
    orderBy: [CompaniesOrderBy!] = [PRIMARY_KEY_ASC]
  ): CategoryCompaniesByServiceCategoryIdAndCompanyIdManyToManyConnection!

  """Reads and enables pagination through a set of `CompanyCategory`."""
  companyCategories(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CompanyCategoryCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: CompanyCategoryFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `CompanyCategory`."""
    orderBy: [CompanyCategoriesOrderBy!] = [PRIMARY_KEY_ASC]
  ): CompanyCategoriesConnection!
  createdAt: Datetime!
  description: String!
  id: UUID!
  name: String!

  """Reads a single `Category` that is related to this `Category`."""
  parent: Category
  parentId: UUID

  """Reads and enables pagination through a set of `Service`."""
  services(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ServiceCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: ServiceFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `Service`."""
    orderBy: [ServicesOrderBy!] = [PRIMARY_KEY_ASC]
  ): ServicesConnection!
  slug: String!
  updatedAt: Datetime!
}

"""The fields on `category` to look up the row to connect."""
input CategoryCategoriesNameKeyConnect {
  name: String!
}

"""The fields on `category` to look up the row to delete."""
input CategoryCategoriesNameKeyDelete {
  name: String!
}

"""The fields on `category` to look up the row to connect."""
input CategoryCategoriesPkeyConnect {
  id: UUID!
}

"""The fields on `category` to look up the row to delete."""
input CategoryCategoriesPkeyDelete {
  id: UUID!
}

"""The fields on `category` to look up the row to connect."""
input CategoryCategoriesSlugKeyConnect {
  slug: String!
}

"""The fields on `category` to look up the row to delete."""
input CategoryCategoriesSlugKeyDelete {
  slug: String!
}

"""A connection to a list of `Company` values, with data from `Service`."""
type CategoryCompaniesByServiceCategoryIdAndCompanyIdManyToManyConnection {
  """
  A list of edges which contains the `Company`, info from the `Service`, and the cursor to aid in pagination.
  """
  edges: [CategoryCompaniesByServiceCategoryIdAndCompanyIdManyToManyEdge!]!

  """A list of `Company` objects."""
  nodes: [Company!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Company` you could get from the connection."""
  totalCount: Int!
}

"""A `Company` edge in the connection, with data from `Service`."""
type CategoryCompaniesByServiceCategoryIdAndCompanyIdManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Company` at the end of the edge."""
  node: Company!

  """Reads and enables pagination through a set of `Service`."""
  services(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ServiceCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: ServiceFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `Service`."""
    orderBy: [ServicesOrderBy!] = [PRIMARY_KEY_ASC]
  ): ServicesConnection!
}

"""
A condition to be used against `Category` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input CategoryCondition {
  """Checks for equality with the object’s `id` field."""
  id: UUID

  """Checks for equality with the object’s `name` field."""
  name: String

  """Checks for equality with the object’s `parentId` field."""
  parentId: UUID

  """Checks for equality with the object’s `slug` field."""
  slug: String
}

"""
A filter to be used against `Category` object types. All fields are combined with a logical ‘and.’
"""
input CategoryFilter {
  """Checks for all expressions in this list."""
  and: [CategoryFilter!]

  """Filter by the object’s `childCategories` relation."""
  childCategories: CategoryToManyCategoryFilter

  """Some related `childCategories` exist."""
  childCategoriesExist: Boolean

  """Filter by the object’s `companyCategories` relation."""
  companyCategories: CategoryToManyCompanyCategoryFilter

  """Some related `companyCategories` exist."""
  companyCategoriesExist: Boolean

  """Filter by the object’s `id` field."""
  id: UUIDFilter

  """Filter by the object’s `name` field."""
  name: StringFilter

  """Negates the expression."""
  not: CategoryFilter

  """Checks for any expressions in this list."""
  or: [CategoryFilter!]

  """Filter by the object’s `parent` relation."""
  parent: CategoryFilter

  """A related `parent` exists."""
  parentExists: Boolean

  """Filter by the object’s `parentId` field."""
  parentId: UUIDFilter

  """Filter by the object’s `services` relation."""
  services: CategoryToManyServiceFilter

  """Some related `services` exist."""
  servicesExist: Boolean

  """Filter by the object’s `slug` field."""
  slug: StringFilter
}

"""An input for mutations affecting `Category`"""
input CategoryInput {
  categoryToParentId: CategoriesParentIdFkeyInput
  companyCategoriesUsingId: CompanyCategoriesCategoryIdFkeyInverseInput
  description: String!
  name: String!
  parentId: UUID
  servicesUsingId: ServicesCategoryIdFkeyInverseInput
  slug: String!
}

"""The fields on `category` to look up the row to update."""
input CategoryOnCategoryForCategoriesParentIdFkeyUsingCategoriesNameKeyUpdate {
  name: String!

  """
  An object where the defined keys will be set on the `category` being updated.
  """
  patch: updateCategoryOnCategoryForCategoriesParentIdFkeyPatch!
}

"""The fields on `category` to look up the row to update."""
input CategoryOnCategoryForCategoriesParentIdFkeyUsingCategoriesPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `category` being updated.
  """
  patch: updateCategoryOnCategoryForCategoriesParentIdFkeyPatch!
}

"""The fields on `category` to look up the row to update."""
input CategoryOnCategoryForCategoriesParentIdFkeyUsingCategoriesSlugKeyUpdate {
  """
  An object where the defined keys will be set on the `category` being updated.
  """
  patch: updateCategoryOnCategoryForCategoriesParentIdFkeyPatch!
  slug: String!
}

"""The fields on `category` to look up the row to update."""
input CategoryOnCompanyCategoryForCompanyCategoriesCategoryIdFkeyUsingCategoriesNameKeyUpdate {
  name: String!

  """
  An object where the defined keys will be set on the `category` being updated.
  """
  patch: updateCategoryOnCompanyCategoryForCompanyCategoriesCategoryIdFkeyPatch!
}

"""The fields on `category` to look up the row to update."""
input CategoryOnCompanyCategoryForCompanyCategoriesCategoryIdFkeyUsingCategoriesPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `category` being updated.
  """
  patch: updateCategoryOnCompanyCategoryForCompanyCategoriesCategoryIdFkeyPatch!
}

"""The fields on `category` to look up the row to update."""
input CategoryOnCompanyCategoryForCompanyCategoriesCategoryIdFkeyUsingCategoriesSlugKeyUpdate {
  """
  An object where the defined keys will be set on the `category` being updated.
  """
  patch: updateCategoryOnCompanyCategoryForCompanyCategoriesCategoryIdFkeyPatch!
  slug: String!
}

"""The fields on `category` to look up the row to update."""
input CategoryOnServiceForServicesCategoryIdFkeyUsingCategoriesNameKeyUpdate {
  name: String!

  """
  An object where the defined keys will be set on the `category` being updated.
  """
  patch: updateCategoryOnServiceForServicesCategoryIdFkeyPatch!
}

"""The fields on `category` to look up the row to update."""
input CategoryOnServiceForServicesCategoryIdFkeyUsingCategoriesPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `category` being updated.
  """
  patch: updateCategoryOnServiceForServicesCategoryIdFkeyPatch!
}

"""The fields on `category` to look up the row to update."""
input CategoryOnServiceForServicesCategoryIdFkeyUsingCategoriesSlugKeyUpdate {
  """
  An object where the defined keys will be set on the `category` being updated.
  """
  patch: updateCategoryOnServiceForServicesCategoryIdFkeyPatch!
  slug: String!
}

"""
Represents an update to a `Category`. Fields that are set will be updated.
"""
input CategoryPatch {
  categoryToParentId: CategoriesParentIdFkeyInput
  companyCategoriesUsingId: CompanyCategoriesCategoryIdFkeyInverseInput
  description: String
  name: String
  parentId: UUID
  servicesUsingId: ServicesCategoryIdFkeyInverseInput
  slug: String
}

"""
A filter to be used against many `Category` object types. All fields are combined with a logical ‘and.’
"""
input CategoryToManyCategoryFilter {
  """
  Every related `Category` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: CategoryFilter

  """
  No related `Category` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: CategoryFilter

  """
  Some related `Category` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: CategoryFilter
}

"""
A filter to be used against many `CompanyCategory` object types. All fields are combined with a logical ‘and.’
"""
input CategoryToManyCompanyCategoryFilter {
  """
  Every related `CompanyCategory` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: CompanyCategoryFilter

  """
  No related `CompanyCategory` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: CompanyCategoryFilter

  """
  Some related `CompanyCategory` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: CompanyCategoryFilter
}

"""
A filter to be used against many `Service` object types. All fields are combined with a logical ‘and.’
"""
input CategoryToManyServiceFilter {
  """
  Every related `Service` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: ServiceFilter

  """
  No related `Service` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: ServiceFilter

  """
  Some related `Service` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: ServiceFilter
}

"""A connection to a list of `Company` values."""
type CompaniesConnection {
  """
  A list of edges which contains the `Company` and cursor to aid in pagination.
  """
  edges: [CompaniesEdge!]!

  """A list of `Company` objects."""
  nodes: [Company!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Company` you could get from the connection."""
  totalCount: Int!
}

"""A `Company` edge in the connection."""
type CompaniesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Company` at the end of the edge."""
  node: Company!
}

"""Methods to use when ordering `Company`."""
enum CompaniesOrderBy {
  ID_ASC
  ID_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  USER_ID_ASC
  USER_ID_DESC
}

"""The `company` to be created by this mutation."""
input CompaniesUserIdFkeyCompaniesCreateInput {
  addressUsingId: AddressesCompanyIdFkeyInverseInput
  availabilityUsingId: AvailabilitiesCompanyIdFkeyInverseInput
  companyCategoryUsingId: CompanyCategoriesCompanyIdFkeyInverseInput
  description: String
  isVerified: Boolean
  name: String!
  servicesUsingId: ServicesCompanyIdFkeyInverseInput
  userToUserId: CompaniesUserIdFkeyInput
}

"""
Input for the nested mutation of `user` in the `CompanyInput` mutation.
"""
input CompaniesUserIdFkeyInput {
  """The primary key(s) for `user` for the far side of the relationship."""
  connectById: UserUsersPkeyConnect

  """
  A `UserInput` object that will be created and connected to this object.
  """
  create: CompaniesUserIdFkeyUsersCreateInput

  """The primary key(s) for `user` for the far side of the relationship."""
  deleteById: UserUsersPkeyDelete

  """
  The primary key(s) and patch data for `user` for the far side of the relationship.
  """
  updateById: UserOnCompanyForCompaniesUserIdFkeyUsingUsersPkeyUpdate
}

"""
Input for the nested mutation of `company` in the `UserInput` mutation.
"""
input CompaniesUserIdFkeyInverseInput {
  """The primary key(s) for `company` for the far side of the relationship."""
  connectById: CompanyCompaniesPkeyConnect

  """The primary key(s) for `company` for the far side of the relationship."""
  connectByUserId: CompanyCompaniesUserIdUniqueConnect

  """
  A `CompanyInput` object that will be created and connected to this object.
  """
  create: [CompaniesUserIdFkeyCompaniesCreateInput!]

  """The primary key(s) for `company` for the far side of the relationship."""
  deleteById: CompanyCompaniesPkeyDelete

  """The primary key(s) for `company` for the far side of the relationship."""
  deleteByUserId: CompanyCompaniesUserIdUniqueDelete

  """
  Flag indicating whether all other `company` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) and patch data for `company` for the far side of the relationship.
  """
  updateById: CompanyOnCompanyForCompaniesUserIdFkeyUsingCompaniesPkeyUpdate

  """
  The primary key(s) and patch data for `company` for the far side of the relationship.
  """
  updateByUserId: CompanyOnCompanyForCompaniesUserIdFkeyUsingCompaniesUserIdUniqueUpdate
}

"""The `user` to be created by this mutation."""
input CompaniesUserIdFkeyUsersCreateInput {
  addressesUsingId: AddressesUserIdFkeyInverseInput
  bookingsUsingId: BookingsUserIdFkeyInverseInput
  companyUsingId: CompaniesUserIdFkeyInverseInput
  email: String!
  isAdmin: Boolean
  isVerified: Boolean
  name: String
  password: String
  type: String
}

type Company {
  """Reads a single `Address` that is related to this `Company`."""
  address: Address

  """Reads and enables pagination through a set of `Address`."""
  addresses(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: AddressCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: AddressFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `Address`."""
    orderBy: [AddressesOrderBy!] = [PRIMARY_KEY_ASC]
  ): AddressesConnection! @deprecated(reason: "Please use address instead")

  """Reads and enables pagination through a set of `Availability`."""
  availabilities(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: AvailabilityCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: AvailabilityFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `Availability`."""
    orderBy: [AvailabilitiesOrderBy!] = [PRIMARY_KEY_ASC]
  ): AvailabilitiesConnection! @deprecated(reason: "Please use availability instead")

  """Reads a single `Availability` that is related to this `Company`."""
  availability: Availability

  """Reads and enables pagination through a set of `Category`."""
  categoriesByServiceCompanyIdAndCategoryId(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CategoryCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: CategoryFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `Category`."""
    orderBy: [CategoriesOrderBy!] = [PRIMARY_KEY_ASC]
  ): CompanyCategoriesByServiceCompanyIdAndCategoryIdManyToManyConnection!

  """Reads and enables pagination through a set of `CompanyCategory`."""
  companyCategories(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CompanyCategoryCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: CompanyCategoryFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `CompanyCategory`."""
    orderBy: [CompanyCategoriesOrderBy!] = [PRIMARY_KEY_ASC]
  ): CompanyCategoriesConnection! @deprecated(reason: "Please use companyCategory instead")

  """Reads a single `CompanyCategory` that is related to this `Company`."""
  companyCategory: CompanyCategory
  createdAt: Datetime!
  description: String
  id: UUID!
  isVerified: Boolean!
  name: String!

  """Reads and enables pagination through a set of `Service`."""
  services(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ServiceCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: ServiceFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `Service`."""
    orderBy: [ServicesOrderBy!] = [PRIMARY_KEY_ASC]
  ): ServicesConnection!
  updatedAt: Datetime!

  """Reads a single `User` that is related to this `Company`."""
  user: User
  userId: UUID!
}

"""A connection to a list of `Category` values, with data from `Service`."""
type CompanyCategoriesByServiceCompanyIdAndCategoryIdManyToManyConnection {
  """
  A list of edges which contains the `Category`, info from the `Service`, and the cursor to aid in pagination.
  """
  edges: [CompanyCategoriesByServiceCompanyIdAndCategoryIdManyToManyEdge!]!

  """A list of `Category` objects."""
  nodes: [Category!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Category` you could get from the connection."""
  totalCount: Int!
}

"""A `Category` edge in the connection, with data from `Service`."""
type CompanyCategoriesByServiceCompanyIdAndCategoryIdManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Category` at the end of the edge."""
  node: Category!

  """Reads and enables pagination through a set of `Service`."""
  services(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ServiceCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: ServiceFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `Service`."""
    orderBy: [ServicesOrderBy!] = [PRIMARY_KEY_ASC]
  ): ServicesConnection!
}

"""The `category` to be created by this mutation."""
input CompanyCategoriesCategoryIdFkeyCategoriesCreateInput {
  categoryToParentId: CategoriesParentIdFkeyInput
  companyCategoriesUsingId: CompanyCategoriesCategoryIdFkeyInverseInput
  description: String!
  name: String!
  parentId: UUID
  servicesUsingId: ServicesCategoryIdFkeyInverseInput
  slug: String!
}

"""The `companyCategory` to be created by this mutation."""
input CompanyCategoriesCategoryIdFkeyCompanyCategoriesCreateInput {
  categoryToCategoryId: CompanyCategoriesCategoryIdFkeyInput
  companyId: UUID
  companyToCompanyId: CompanyCategoriesCompanyIdFkeyInput
}

"""
Input for the nested mutation of `category` in the `CompanyCategoryInput` mutation.
"""
input CompanyCategoriesCategoryIdFkeyInput {
  """
  The primary key(s) for `category` for the far side of the relationship.
  """
  connectById: CategoryCategoriesPkeyConnect

  """
  The primary key(s) for `category` for the far side of the relationship.
  """
  connectByName: CategoryCategoriesNameKeyConnect

  """
  The primary key(s) for `category` for the far side of the relationship.
  """
  connectBySlug: CategoryCategoriesSlugKeyConnect

  """
  A `CategoryInput` object that will be created and connected to this object.
  """
  create: CompanyCategoriesCategoryIdFkeyCategoriesCreateInput

  """
  The primary key(s) for `category` for the far side of the relationship.
  """
  deleteById: CategoryCategoriesPkeyDelete

  """
  The primary key(s) for `category` for the far side of the relationship.
  """
  deleteByName: CategoryCategoriesNameKeyDelete

  """
  The primary key(s) for `category` for the far side of the relationship.
  """
  deleteBySlug: CategoryCategoriesSlugKeyDelete

  """
  The primary key(s) and patch data for `category` for the far side of the relationship.
  """
  updateById: CategoryOnCompanyCategoryForCompanyCategoriesCategoryIdFkeyUsingCategoriesPkeyUpdate

  """
  The primary key(s) and patch data for `category` for the far side of the relationship.
  """
  updateByName: CategoryOnCompanyCategoryForCompanyCategoriesCategoryIdFkeyUsingCategoriesNameKeyUpdate

  """
  The primary key(s) and patch data for `category` for the far side of the relationship.
  """
  updateBySlug: CategoryOnCompanyCategoryForCompanyCategoriesCategoryIdFkeyUsingCategoriesSlugKeyUpdate
}

"""
Input for the nested mutation of `companyCategory` in the `CategoryInput` mutation.
"""
input CompanyCategoriesCategoryIdFkeyInverseInput {
  """
  The primary key(s) for `companyCategory` for the far side of the relationship.
  """
  connectByCompanyId: [CompanyCategoryCompanyCategoriesCompanyIdUniqueConnect!]

  """
  The primary key(s) for `companyCategory` for the far side of the relationship.
  """
  connectById: [CompanyCategoryCompanyCategoriesPkeyConnect!]

  """
  A `CompanyCategoryInput` object that will be created and connected to this object.
  """
  create: [CompanyCategoriesCategoryIdFkeyCompanyCategoriesCreateInput!]

  """
  The primary key(s) for `companyCategory` for the far side of the relationship.
  """
  deleteByCompanyId: [CompanyCategoryCompanyCategoriesCompanyIdUniqueDelete!]

  """
  The primary key(s) for `companyCategory` for the far side of the relationship.
  """
  deleteById: [CompanyCategoryCompanyCategoriesPkeyDelete!]

  """
  Flag indicating whether all other `companyCategory` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) and patch data for `companyCategory` for the far side of the relationship.
  """
  updateByCompanyId: [CompanyCategoryOnCompanyCategoryForCompanyCategoriesCategoryIdFkeyUsingCompanyCategoriesCompanyIdUniqueUpdate!]

  """
  The primary key(s) and patch data for `companyCategory` for the far side of the relationship.
  """
  updateById: [CompanyCategoryOnCompanyCategoryForCompanyCategoriesCategoryIdFkeyUsingCompanyCategoriesPkeyUpdate!]
}

"""The `company` to be created by this mutation."""
input CompanyCategoriesCompanyIdFkeyCompaniesCreateInput {
  addressUsingId: AddressesCompanyIdFkeyInverseInput
  availabilityUsingId: AvailabilitiesCompanyIdFkeyInverseInput
  companyCategoryUsingId: CompanyCategoriesCompanyIdFkeyInverseInput
  description: String
  isVerified: Boolean
  name: String!
  servicesUsingId: ServicesCompanyIdFkeyInverseInput
  userId: UUID
  userToUserId: CompaniesUserIdFkeyInput
}

"""The `companyCategory` to be created by this mutation."""
input CompanyCategoriesCompanyIdFkeyCompanyCategoriesCreateInput {
  categoryId: UUID
  categoryToCategoryId: CompanyCategoriesCategoryIdFkeyInput
  companyToCompanyId: CompanyCategoriesCompanyIdFkeyInput
}

"""
Input for the nested mutation of `company` in the `CompanyCategoryInput` mutation.
"""
input CompanyCategoriesCompanyIdFkeyInput {
  """The primary key(s) for `company` for the far side of the relationship."""
  connectById: CompanyCompaniesPkeyConnect

  """The primary key(s) for `company` for the far side of the relationship."""
  connectByUserId: CompanyCompaniesUserIdUniqueConnect

  """
  A `CompanyInput` object that will be created and connected to this object.
  """
  create: CompanyCategoriesCompanyIdFkeyCompaniesCreateInput

  """The primary key(s) for `company` for the far side of the relationship."""
  deleteById: CompanyCompaniesPkeyDelete

  """The primary key(s) for `company` for the far side of the relationship."""
  deleteByUserId: CompanyCompaniesUserIdUniqueDelete

  """
  The primary key(s) and patch data for `company` for the far side of the relationship.
  """
  updateById: CompanyOnCompanyCategoryForCompanyCategoriesCompanyIdFkeyUsingCompaniesPkeyUpdate

  """
  The primary key(s) and patch data for `company` for the far side of the relationship.
  """
  updateByUserId: CompanyOnCompanyCategoryForCompanyCategoriesCompanyIdFkeyUsingCompaniesUserIdUniqueUpdate
}

"""
Input for the nested mutation of `companyCategory` in the `CompanyInput` mutation.
"""
input CompanyCategoriesCompanyIdFkeyInverseInput {
  """
  The primary key(s) for `companyCategory` for the far side of the relationship.
  """
  connectByCompanyId: CompanyCategoryCompanyCategoriesCompanyIdUniqueConnect

  """
  The primary key(s) for `companyCategory` for the far side of the relationship.
  """
  connectById: CompanyCategoryCompanyCategoriesPkeyConnect

  """
  A `CompanyCategoryInput` object that will be created and connected to this object.
  """
  create: [CompanyCategoriesCompanyIdFkeyCompanyCategoriesCreateInput!]

  """
  The primary key(s) for `companyCategory` for the far side of the relationship.
  """
  deleteByCompanyId: CompanyCategoryCompanyCategoriesCompanyIdUniqueDelete

  """
  The primary key(s) for `companyCategory` for the far side of the relationship.
  """
  deleteById: CompanyCategoryCompanyCategoriesPkeyDelete

  """
  Flag indicating whether all other `companyCategory` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) and patch data for `companyCategory` for the far side of the relationship.
  """
  updateByCompanyId: CompanyCategoryOnCompanyCategoryForCompanyCategoriesCompanyIdFkeyUsingCompanyCategoriesCompanyIdUniqueUpdate

  """
  The primary key(s) and patch data for `companyCategory` for the far side of the relationship.
  """
  updateById: CompanyCategoryOnCompanyCategoryForCompanyCategoriesCompanyIdFkeyUsingCompanyCategoriesPkeyUpdate
}

"""A connection to a list of `CompanyCategory` values."""
type CompanyCategoriesConnection {
  """
  A list of edges which contains the `CompanyCategory` and cursor to aid in pagination.
  """
  edges: [CompanyCategoriesEdge!]!

  """A list of `CompanyCategory` objects."""
  nodes: [CompanyCategory!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """
  The count of *all* `CompanyCategory` you could get from the connection.
  """
  totalCount: Int!
}

"""A `CompanyCategory` edge in the connection."""
type CompanyCategoriesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `CompanyCategory` at the end of the edge."""
  node: CompanyCategory!
}

"""Methods to use when ordering `CompanyCategory`."""
enum CompanyCategoriesOrderBy {
  CATEGORY_ID_ASC
  CATEGORY_ID_DESC
  COMPANY_ID_ASC
  COMPANY_ID_DESC
  ID_ASC
  ID_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

type CompanyCategory {
  """Reads a single `Category` that is related to this `CompanyCategory`."""
  category: Category
  categoryId: UUID!

  """Reads a single `Company` that is related to this `CompanyCategory`."""
  company: Company
  companyId: UUID!
  createdAt: Datetime!
  id: UUID!
}

"""The fields on `companyCategory` to look up the row to connect."""
input CompanyCategoryCompanyCategoriesCompanyIdUniqueConnect {
  companyId: UUID!
}

"""The fields on `companyCategory` to look up the row to delete."""
input CompanyCategoryCompanyCategoriesCompanyIdUniqueDelete {
  companyId: UUID!
}

"""The fields on `companyCategory` to look up the row to connect."""
input CompanyCategoryCompanyCategoriesPkeyConnect {
  id: UUID!
}

"""The fields on `companyCategory` to look up the row to delete."""
input CompanyCategoryCompanyCategoriesPkeyDelete {
  id: UUID!
}

"""
A condition to be used against `CompanyCategory` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input CompanyCategoryCondition {
  """Checks for equality with the object’s `categoryId` field."""
  categoryId: UUID

  """Checks for equality with the object’s `companyId` field."""
  companyId: UUID

  """Checks for equality with the object’s `id` field."""
  id: UUID
}

"""
A filter to be used against `CompanyCategory` object types. All fields are combined with a logical ‘and.’
"""
input CompanyCategoryFilter {
  """Checks for all expressions in this list."""
  and: [CompanyCategoryFilter!]

  """Filter by the object’s `category` relation."""
  category: CategoryFilter

  """Filter by the object’s `categoryId` field."""
  categoryId: UUIDFilter

  """Filter by the object’s `company` relation."""
  company: CompanyFilter

  """Filter by the object’s `companyId` field."""
  companyId: UUIDFilter

  """Filter by the object’s `id` field."""
  id: UUIDFilter

  """Negates the expression."""
  not: CompanyCategoryFilter

  """Checks for any expressions in this list."""
  or: [CompanyCategoryFilter!]
}

"""An input for mutations affecting `CompanyCategory`"""
input CompanyCategoryInput {
  categoryId: UUID
  categoryToCategoryId: CompanyCategoriesCategoryIdFkeyInput
  companyId: UUID
  companyToCompanyId: CompanyCategoriesCompanyIdFkeyInput
}

"""The fields on `companyCategory` to look up the row to update."""
input CompanyCategoryOnCompanyCategoryForCompanyCategoriesCategoryIdFkeyUsingCompanyCategoriesCompanyIdUniqueUpdate {
  companyId: UUID!

  """
  An object where the defined keys will be set on the `companyCategory` being updated.
  """
  patch: updateCompanyCategoryOnCompanyCategoryForCompanyCategoriesCategoryIdFkeyPatch!
}

"""The fields on `companyCategory` to look up the row to update."""
input CompanyCategoryOnCompanyCategoryForCompanyCategoriesCategoryIdFkeyUsingCompanyCategoriesPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `companyCategory` being updated.
  """
  patch: updateCompanyCategoryOnCompanyCategoryForCompanyCategoriesCategoryIdFkeyPatch!
}

"""The fields on `companyCategory` to look up the row to update."""
input CompanyCategoryOnCompanyCategoryForCompanyCategoriesCompanyIdFkeyUsingCompanyCategoriesCompanyIdUniqueUpdate {
  companyId: UUID!

  """
  An object where the defined keys will be set on the `companyCategory` being updated.
  """
  patch: updateCompanyCategoryOnCompanyCategoryForCompanyCategoriesCompanyIdFkeyPatch!
}

"""The fields on `companyCategory` to look up the row to update."""
input CompanyCategoryOnCompanyCategoryForCompanyCategoriesCompanyIdFkeyUsingCompanyCategoriesPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `companyCategory` being updated.
  """
  patch: updateCompanyCategoryOnCompanyCategoryForCompanyCategoriesCompanyIdFkeyPatch!
}

"""
Represents an update to a `CompanyCategory`. Fields that are set will be updated.
"""
input CompanyCategoryPatch {
  categoryId: UUID
  categoryToCategoryId: CompanyCategoriesCategoryIdFkeyInput
  companyId: UUID
  companyToCompanyId: CompanyCategoriesCompanyIdFkeyInput
}

"""The fields on `company` to look up the row to connect."""
input CompanyCompaniesPkeyConnect {
  id: UUID!
}

"""The fields on `company` to look up the row to delete."""
input CompanyCompaniesPkeyDelete {
  id: UUID!
}

"""The fields on `company` to look up the row to connect."""
input CompanyCompaniesUserIdUniqueConnect {
  userId: UUID!
}

"""The fields on `company` to look up the row to delete."""
input CompanyCompaniesUserIdUniqueDelete {
  userId: UUID!
}

"""
A condition to be used against `Company` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input CompanyCondition {
  """Checks for equality with the object’s `id` field."""
  id: UUID

  """Checks for equality with the object’s `userId` field."""
  userId: UUID
}

"""
A filter to be used against `Company` object types. All fields are combined with a logical ‘and.’
"""
input CompanyFilter {
  """Filter by the object’s `address` relation."""
  address: AddressFilter

  """A related `address` exists."""
  addressExists: Boolean

  """Checks for all expressions in this list."""
  and: [CompanyFilter!]

  """Filter by the object’s `availability` relation."""
  availability: AvailabilityFilter

  """A related `availability` exists."""
  availabilityExists: Boolean

  """Filter by the object’s `companyCategory` relation."""
  companyCategory: CompanyCategoryFilter

  """A related `companyCategory` exists."""
  companyCategoryExists: Boolean

  """Filter by the object’s `id` field."""
  id: UUIDFilter

  """Negates the expression."""
  not: CompanyFilter

  """Checks for any expressions in this list."""
  or: [CompanyFilter!]

  """Filter by the object’s `services` relation."""
  services: CompanyToManyServiceFilter

  """Some related `services` exist."""
  servicesExist: Boolean

  """Filter by the object’s `user` relation."""
  user: UserFilter

  """Filter by the object’s `userId` field."""
  userId: UUIDFilter
}

"""An input for mutations affecting `Company`"""
input CompanyInput {
  addressUsingId: AddressesCompanyIdFkeyInverseInput
  availabilityUsingId: AvailabilitiesCompanyIdFkeyInverseInput
  companyCategoryUsingId: CompanyCategoriesCompanyIdFkeyInverseInput
  description: String
  isVerified: Boolean
  name: String!
  servicesUsingId: ServicesCompanyIdFkeyInverseInput
  userId: UUID
  userToUserId: CompaniesUserIdFkeyInput
}

"""The fields on `company` to look up the row to update."""
input CompanyOnAddressForAddressesCompanyIdFkeyUsingCompaniesPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `company` being updated.
  """
  patch: updateCompanyOnAddressForAddressesCompanyIdFkeyPatch!
}

"""The fields on `company` to look up the row to update."""
input CompanyOnAddressForAddressesCompanyIdFkeyUsingCompaniesUserIdUniqueUpdate {
  """
  An object where the defined keys will be set on the `company` being updated.
  """
  patch: updateCompanyOnAddressForAddressesCompanyIdFkeyPatch!
  userId: UUID!
}

"""The fields on `company` to look up the row to update."""
input CompanyOnAvailabilityForAvailabilitiesCompanyIdFkeyUsingCompaniesPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `company` being updated.
  """
  patch: updateCompanyOnAvailabilityForAvailabilitiesCompanyIdFkeyPatch!
}

"""The fields on `company` to look up the row to update."""
input CompanyOnAvailabilityForAvailabilitiesCompanyIdFkeyUsingCompaniesUserIdUniqueUpdate {
  """
  An object where the defined keys will be set on the `company` being updated.
  """
  patch: updateCompanyOnAvailabilityForAvailabilitiesCompanyIdFkeyPatch!
  userId: UUID!
}

"""The fields on `company` to look up the row to update."""
input CompanyOnCompanyCategoryForCompanyCategoriesCompanyIdFkeyUsingCompaniesPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `company` being updated.
  """
  patch: updateCompanyOnCompanyCategoryForCompanyCategoriesCompanyIdFkeyPatch!
}

"""The fields on `company` to look up the row to update."""
input CompanyOnCompanyCategoryForCompanyCategoriesCompanyIdFkeyUsingCompaniesUserIdUniqueUpdate {
  """
  An object where the defined keys will be set on the `company` being updated.
  """
  patch: updateCompanyOnCompanyCategoryForCompanyCategoriesCompanyIdFkeyPatch!
  userId: UUID!
}

"""The fields on `company` to look up the row to update."""
input CompanyOnCompanyForCompaniesUserIdFkeyUsingCompaniesPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `company` being updated.
  """
  patch: updateCompanyOnCompanyForCompaniesUserIdFkeyPatch!
}

"""The fields on `company` to look up the row to update."""
input CompanyOnCompanyForCompaniesUserIdFkeyUsingCompaniesUserIdUniqueUpdate {
  """
  An object where the defined keys will be set on the `company` being updated.
  """
  patch: updateCompanyOnCompanyForCompaniesUserIdFkeyPatch!
  userId: UUID!
}

"""The fields on `company` to look up the row to update."""
input CompanyOnServiceForServicesCompanyIdFkeyUsingCompaniesPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `company` being updated.
  """
  patch: updateCompanyOnServiceForServicesCompanyIdFkeyPatch!
}

"""The fields on `company` to look up the row to update."""
input CompanyOnServiceForServicesCompanyIdFkeyUsingCompaniesUserIdUniqueUpdate {
  """
  An object where the defined keys will be set on the `company` being updated.
  """
  patch: updateCompanyOnServiceForServicesCompanyIdFkeyPatch!
  userId: UUID!
}

"""
Represents an update to a `Company`. Fields that are set will be updated.
"""
input CompanyPatch {
  addressUsingId: AddressesCompanyIdFkeyInverseInput
  availabilityUsingId: AvailabilitiesCompanyIdFkeyInverseInput
  companyCategoryUsingId: CompanyCategoriesCompanyIdFkeyInverseInput
  description: String
  isVerified: Boolean
  name: String
  servicesUsingId: ServicesCompanyIdFkeyInverseInput
  userId: UUID
  userToUserId: CompaniesUserIdFkeyInput
}

"""
A filter to be used against many `Service` object types. All fields are combined with a logical ‘and.’
"""
input CompanyToManyServiceFilter {
  """
  Every related `Service` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: ServiceFilter

  """
  No related `Service` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: ServiceFilter

  """
  Some related `Service` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: ServiceFilter
}

"""All input for the create `Address` mutation."""
input CreateAddressInput {
  """The `Address` to be created by this mutation."""
  address: AddressInput!

  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
}

"""The output of our create `Address` mutation."""
type CreateAddressPayload {
  """The `Address` that was created by this mutation."""
  address: Address

  """An edge for our `Address`. May be used by Relay 1."""
  addressEdge(
    """The method to use when ordering `Address`."""
    orderBy: [AddressesOrderBy!] = [PRIMARY_KEY_ASC]
  ): AddressesEdge

  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """Reads a single `Company` that is related to this `Address`."""
  company: Company

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `Address`."""
  user: User
}

"""All input for the create `Availability` mutation."""
input CreateAvailabilityInput {
  """The `Availability` to be created by this mutation."""
  availability: AvailabilityInput!

  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
}

"""The output of our create `Availability` mutation."""
type CreateAvailabilityPayload {
  """The `Availability` that was created by this mutation."""
  availability: Availability

  """An edge for our `Availability`. May be used by Relay 1."""
  availabilityEdge(
    """The method to use when ordering `Availability`."""
    orderBy: [AvailabilitiesOrderBy!] = [PRIMARY_KEY_ASC]
  ): AvailabilitiesEdge

  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """Reads a single `Company` that is related to this `Availability`."""
  company: Company

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the create `Booking` mutation."""
input CreateBookingInput {
  """The `Booking` to be created by this mutation."""
  booking: BookingInput!

  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
}

"""The output of our create `Booking` mutation."""
type CreateBookingPayload {
  """Reads a single `Address` that is related to this `Booking`."""
  address: Address

  """Reads a single `Availability` that is related to this `Booking`."""
  availability: Availability

  """The `Booking` that was created by this mutation."""
  booking: Booking

  """An edge for our `Booking`. May be used by Relay 1."""
  bookingEdge(
    """The method to use when ordering `Booking`."""
    orderBy: [BookingsOrderBy!] = [PRIMARY_KEY_ASC]
  ): BookingsEdge

  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Service` that is related to this `Booking`."""
  service: Service

  """Reads a single `User` that is related to this `Booking`."""
  user: User
}

"""All input for the create `Category` mutation."""
input CreateCategoryInput {
  """The `Category` to be created by this mutation."""
  category: CategoryInput!

  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
}

"""The output of our create `Category` mutation."""
type CreateCategoryPayload {
  """The `Category` that was created by this mutation."""
  category: Category

  """An edge for our `Category`. May be used by Relay 1."""
  categoryEdge(
    """The method to use when ordering `Category`."""
    orderBy: [CategoriesOrderBy!] = [PRIMARY_KEY_ASC]
  ): CategoriesEdge

  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """Reads a single `Category` that is related to this `Category`."""
  parent: Category

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the create `CompanyCategory` mutation."""
input CreateCompanyCategoryInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `CompanyCategory` to be created by this mutation."""
  companyCategory: CompanyCategoryInput!
}

"""The output of our create `CompanyCategory` mutation."""
type CreateCompanyCategoryPayload {
  """Reads a single `Category` that is related to this `CompanyCategory`."""
  category: Category

  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """Reads a single `Company` that is related to this `CompanyCategory`."""
  company: Company

  """The `CompanyCategory` that was created by this mutation."""
  companyCategory: CompanyCategory

  """An edge for our `CompanyCategory`. May be used by Relay 1."""
  companyCategoryEdge(
    """The method to use when ordering `CompanyCategory`."""
    orderBy: [CompanyCategoriesOrderBy!] = [PRIMARY_KEY_ASC]
  ): CompanyCategoriesEdge

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the create `Company` mutation."""
input CreateCompanyInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Company` to be created by this mutation."""
  company: CompanyInput!
}

"""The output of our create `Company` mutation."""
type CreateCompanyPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Company` that was created by this mutation."""
  company: Company

  """An edge for our `Company`. May be used by Relay 1."""
  companyEdge(
    """The method to use when ordering `Company`."""
    orderBy: [CompaniesOrderBy!] = [PRIMARY_KEY_ASC]
  ): CompaniesEdge

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `Company`."""
  user: User
}

"""All input for the create `Service` mutation."""
input CreateServiceInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Service` to be created by this mutation."""
  service: ServiceInput!
}

"""The output of our create `Service` mutation."""
type CreateServicePayload {
  """Reads a single `Category` that is related to this `Service`."""
  category: Category

  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """Reads a single `Company` that is related to this `Service`."""
  company: Company

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """The `Service` that was created by this mutation."""
  service: Service

  """An edge for our `Service`. May be used by Relay 1."""
  serviceEdge(
    """The method to use when ordering `Service`."""
    orderBy: [ServicesOrderBy!] = [PRIMARY_KEY_ASC]
  ): ServicesEdge
}

"""All input for the create `User` mutation."""
input CreateUserInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `User` to be created by this mutation."""
  user: UserInput!
}

"""The output of our create `User` mutation."""
type CreateUserPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """The `User` that was created by this mutation."""
  user: User

  """An edge for our `User`. May be used by Relay 1."""
  userEdge(
    """The method to use when ordering `User`."""
    orderBy: [UsersOrderBy!] = [PRIMARY_KEY_ASC]
  ): UsersEdge
}

"""A location in a connection that can be used for resuming pagination."""
scalar Cursor

"""
A point in time as described by the [ISO
8601](https://en.wikipedia.org/wiki/ISO_8601) standard. May or may not include a timezone.
"""
scalar Datetime

"""All input for the `deleteAddressByCompanyId` mutation."""
input DeleteAddressByCompanyIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  companyId: UUID!
}

"""All input for the `deleteAddress` mutation."""
input DeleteAddressInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: UUID!
}

"""The output of our delete `Address` mutation."""
type DeleteAddressPayload {
  """The `Address` that was deleted by this mutation."""
  address: Address

  """An edge for our `Address`. May be used by Relay 1."""
  addressEdge(
    """The method to use when ordering `Address`."""
    orderBy: [AddressesOrderBy!] = [PRIMARY_KEY_ASC]
  ): AddressesEdge

  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """Reads a single `Company` that is related to this `Address`."""
  company: Company
  deletedAddressNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `Address`."""
  user: User
}

"""All input for the `deleteAvailabilityByCompanyId` mutation."""
input DeleteAvailabilityByCompanyIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  companyId: UUID!
}

"""All input for the `deleteAvailability` mutation."""
input DeleteAvailabilityInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: UUID!
}

"""The output of our delete `Availability` mutation."""
type DeleteAvailabilityPayload {
  """The `Availability` that was deleted by this mutation."""
  availability: Availability

  """An edge for our `Availability`. May be used by Relay 1."""
  availabilityEdge(
    """The method to use when ordering `Availability`."""
    orderBy: [AvailabilitiesOrderBy!] = [PRIMARY_KEY_ASC]
  ): AvailabilitiesEdge

  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """Reads a single `Company` that is related to this `Availability`."""
  company: Company
  deletedAvailabilityNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the `deleteBooking` mutation."""
input DeleteBookingInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: UUID!
}

"""The output of our delete `Booking` mutation."""
type DeleteBookingPayload {
  """Reads a single `Address` that is related to this `Booking`."""
  address: Address

  """Reads a single `Availability` that is related to this `Booking`."""
  availability: Availability

  """The `Booking` that was deleted by this mutation."""
  booking: Booking

  """An edge for our `Booking`. May be used by Relay 1."""
  bookingEdge(
    """The method to use when ordering `Booking`."""
    orderBy: [BookingsOrderBy!] = [PRIMARY_KEY_ASC]
  ): BookingsEdge

  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  deletedBookingNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Service` that is related to this `Booking`."""
  service: Service

  """Reads a single `User` that is related to this `Booking`."""
  user: User
}

"""All input for the `deleteCategoryByName` mutation."""
input DeleteCategoryByNameInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  name: String!
}

"""All input for the `deleteCategoryBySlug` mutation."""
input DeleteCategoryBySlugInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  slug: String!
}

"""All input for the `deleteCategory` mutation."""
input DeleteCategoryInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: UUID!
}

"""The output of our delete `Category` mutation."""
type DeleteCategoryPayload {
  """The `Category` that was deleted by this mutation."""
  category: Category

  """An edge for our `Category`. May be used by Relay 1."""
  categoryEdge(
    """The method to use when ordering `Category`."""
    orderBy: [CategoriesOrderBy!] = [PRIMARY_KEY_ASC]
  ): CategoriesEdge

  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  deletedCategoryNodeId: ID

  """Reads a single `Category` that is related to this `Category`."""
  parent: Category

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the `deleteCompanyByUserId` mutation."""
input DeleteCompanyByUserIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  userId: UUID!
}

"""All input for the `deleteCompanyCategoryByCompanyId` mutation."""
input DeleteCompanyCategoryByCompanyIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  companyId: UUID!
}

"""All input for the `deleteCompanyCategory` mutation."""
input DeleteCompanyCategoryInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: UUID!
}

"""The output of our delete `CompanyCategory` mutation."""
type DeleteCompanyCategoryPayload {
  """Reads a single `Category` that is related to this `CompanyCategory`."""
  category: Category

  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """Reads a single `Company` that is related to this `CompanyCategory`."""
  company: Company

  """The `CompanyCategory` that was deleted by this mutation."""
  companyCategory: CompanyCategory

  """An edge for our `CompanyCategory`. May be used by Relay 1."""
  companyCategoryEdge(
    """The method to use when ordering `CompanyCategory`."""
    orderBy: [CompanyCategoriesOrderBy!] = [PRIMARY_KEY_ASC]
  ): CompanyCategoriesEdge
  deletedCompanyCategoryNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the `deleteCompany` mutation."""
input DeleteCompanyInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: UUID!
}

"""The output of our delete `Company` mutation."""
type DeleteCompanyPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Company` that was deleted by this mutation."""
  company: Company

  """An edge for our `Company`. May be used by Relay 1."""
  companyEdge(
    """The method to use when ordering `Company`."""
    orderBy: [CompaniesOrderBy!] = [PRIMARY_KEY_ASC]
  ): CompaniesEdge
  deletedCompanyNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `Company`."""
  user: User
}

"""All input for the `deleteService` mutation."""
input DeleteServiceInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: UUID!
}

"""The output of our delete `Service` mutation."""
type DeleteServicePayload {
  """Reads a single `Category` that is related to this `Service`."""
  category: Category

  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """Reads a single `Company` that is related to this `Service`."""
  company: Company
  deletedServiceNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """The `Service` that was deleted by this mutation."""
  service: Service

  """An edge for our `Service`. May be used by Relay 1."""
  serviceEdge(
    """The method to use when ordering `Service`."""
    orderBy: [ServicesOrderBy!] = [PRIMARY_KEY_ASC]
  ): ServicesEdge
}

"""All input for the `deleteUser` mutation."""
input DeleteUserInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: UUID!
}

"""The output of our delete `User` mutation."""
type DeleteUserPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  deletedUserNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """The `User` that was deleted by this mutation."""
  user: User

  """An edge for our `User`. May be used by Relay 1."""
  userEdge(
    """The method to use when ordering `User`."""
    orderBy: [UsersOrderBy!] = [PRIMARY_KEY_ASC]
  ): UsersEdge
}

input LoginInput {
  email: String!
  password: String!
}

type LoginPayload {
  token: String
  user: User!
}

type LogoutPayload {
  success: Boolean
}

"""
The root mutation type which contains root level fields which mutate data.
"""
type Mutation {
  """Creates a single `Address`."""
  createAddress(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateAddressInput!
  ): CreateAddressPayload

  """Creates a single `Availability`."""
  createAvailability(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateAvailabilityInput!
  ): CreateAvailabilityPayload

  """Creates a single `Booking`."""
  createBooking(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateBookingInput!
  ): CreateBookingPayload

  """Creates a single `Category`."""
  createCategory(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateCategoryInput!
  ): CreateCategoryPayload

  """Creates a single `Company`."""
  createCompany(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateCompanyInput!
  ): CreateCompanyPayload

  """Creates a single `CompanyCategory`."""
  createCompanyCategory(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateCompanyCategoryInput!
  ): CreateCompanyCategoryPayload

  """Creates a single `Service`."""
  createService(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateServiceInput!
  ): CreateServicePayload

  """Creates a single `User`."""
  createUser(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateUserInput!
  ): CreateUserPayload

  """Deletes a single `Address` using a unique key."""
  deleteAddress(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteAddressInput!
  ): DeleteAddressPayload

  """Deletes a single `Address` using a unique key."""
  deleteAddressByCompanyId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteAddressByCompanyIdInput!
  ): DeleteAddressPayload

  """Deletes a single `Availability` using a unique key."""
  deleteAvailability(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteAvailabilityInput!
  ): DeleteAvailabilityPayload

  """Deletes a single `Availability` using a unique key."""
  deleteAvailabilityByCompanyId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteAvailabilityByCompanyIdInput!
  ): DeleteAvailabilityPayload

  """Deletes a single `Booking` using a unique key."""
  deleteBooking(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteBookingInput!
  ): DeleteBookingPayload

  """Deletes a single `Category` using a unique key."""
  deleteCategory(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteCategoryInput!
  ): DeleteCategoryPayload

  """Deletes a single `Category` using a unique key."""
  deleteCategoryByName(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteCategoryByNameInput!
  ): DeleteCategoryPayload

  """Deletes a single `Category` using a unique key."""
  deleteCategoryBySlug(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteCategoryBySlugInput!
  ): DeleteCategoryPayload

  """Deletes a single `Company` using a unique key."""
  deleteCompany(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteCompanyInput!
  ): DeleteCompanyPayload

  """Deletes a single `Company` using a unique key."""
  deleteCompanyByUserId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteCompanyByUserIdInput!
  ): DeleteCompanyPayload

  """Deletes a single `CompanyCategory` using a unique key."""
  deleteCompanyCategory(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteCompanyCategoryInput!
  ): DeleteCompanyCategoryPayload

  """Deletes a single `CompanyCategory` using a unique key."""
  deleteCompanyCategoryByCompanyId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteCompanyCategoryByCompanyIdInput!
  ): DeleteCompanyCategoryPayload

  """Deletes a single `Service` using a unique key."""
  deleteService(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteServiceInput!
  ): DeleteServicePayload

  """Deletes a single `User` using a unique key."""
  deleteUser(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteUserInput!
  ): DeleteUserPayload

  """
  Use this mutation to log in to your account; this login uses sessions so you do not need to take further action.
  """
  login(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: LoginInput!
  ): LoginPayload

  """
  Use this mutation to logout from your account. Don't forget to clear the client state!
  """
  logout: LogoutPayload

  """
  Use this mutation to create an account on our system. This may only be used if you are logged out.
  """
  register(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: RegisterInput!
  ): RegisterPayload
  registerCompany(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: RegisterCompanyInput!
  ): RegisterCompanyPayload

  """
  After triggering forgotPassword, you'll be sent a reset token. Combine this with your user ID and a new password to reset your password.
  """
  resetPassword(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: ResetPasswordInput!
  ): ResetPasswordPayload

  """Updates a single `Address` using a unique key and a patch."""
  updateAddress(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateAddressInput!
  ): UpdateAddressPayload

  """Updates a single `Address` using a unique key and a patch."""
  updateAddressByCompanyId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateAddressByCompanyIdInput!
  ): UpdateAddressPayload

  """Updates a single `Availability` using a unique key and a patch."""
  updateAvailability(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateAvailabilityInput!
  ): UpdateAvailabilityPayload

  """Updates a single `Availability` using a unique key and a patch."""
  updateAvailabilityByCompanyId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateAvailabilityByCompanyIdInput!
  ): UpdateAvailabilityPayload

  """Updates a single `Booking` using a unique key and a patch."""
  updateBooking(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateBookingInput!
  ): UpdateBookingPayload

  """Updates a single `Category` using a unique key and a patch."""
  updateCategory(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateCategoryInput!
  ): UpdateCategoryPayload

  """Updates a single `Category` using a unique key and a patch."""
  updateCategoryByName(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateCategoryByNameInput!
  ): UpdateCategoryPayload

  """Updates a single `Category` using a unique key and a patch."""
  updateCategoryBySlug(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateCategoryBySlugInput!
  ): UpdateCategoryPayload

  """Updates a single `Company` using a unique key and a patch."""
  updateCompany(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateCompanyInput!
  ): UpdateCompanyPayload

  """Updates a single `Company` using a unique key and a patch."""
  updateCompanyByUserId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateCompanyByUserIdInput!
  ): UpdateCompanyPayload

  """Updates a single `CompanyCategory` using a unique key and a patch."""
  updateCompanyCategory(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateCompanyCategoryInput!
  ): UpdateCompanyCategoryPayload

  """Updates a single `CompanyCategory` using a unique key and a patch."""
  updateCompanyCategoryByCompanyId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateCompanyCategoryByCompanyIdInput!
  ): UpdateCompanyCategoryPayload

  """Updates a single `Service` using a unique key and a patch."""
  updateService(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateServiceInput!
  ): UpdateServicePayload

  """Updates a single `User` using a unique key and a patch."""
  updateUser(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateUserInput!
  ): UpdateUserPayload
}

"""Information about pagination in a connection."""
type PageInfo {
  """When paginating forwards, the cursor to continue."""
  endCursor: Cursor

  """When paginating forwards, are there more items?"""
  hasNextPage: Boolean!

  """When paginating backwards, are there more items?"""
  hasPreviousPage: Boolean!

  """When paginating backwards, the cursor to continue."""
  startCursor: Cursor
}

"""The root query type which gives access points into the data universe."""
type Query {
  address(id: UUID!): Address
  addressByCompanyId(companyId: UUID!): Address

  """Reads and enables pagination through a set of `Address`."""
  addresses(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: AddressCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: AddressFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `Address`."""
    orderBy: [AddressesOrderBy!] = [PRIMARY_KEY_ASC]
  ): AddressesConnection

  """Reads and enables pagination through a set of `Availability`."""
  availabilities(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: AvailabilityCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: AvailabilityFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `Availability`."""
    orderBy: [AvailabilitiesOrderBy!] = [PRIMARY_KEY_ASC]
  ): AvailabilitiesConnection
  availability(id: UUID!): Availability
  availabilityByCompanyId(companyId: UUID!): Availability
  booking(id: UUID!): Booking

  """Reads and enables pagination through a set of `Booking`."""
  bookings(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: BookingCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: BookingFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `Booking`."""
    orderBy: [BookingsOrderBy!] = [PRIMARY_KEY_ASC]
  ): BookingsConnection

  """Reads and enables pagination through a set of `Category`."""
  categories(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CategoryCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: CategoryFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `Category`."""
    orderBy: [CategoriesOrderBy!] = [PRIMARY_KEY_ASC]
  ): CategoriesConnection
  category(id: UUID!): Category
  categoryByName(name: String!): Category
  categoryBySlug(slug: String!): Category

  """Reads and enables pagination through a set of `Company`."""
  companies(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CompanyCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: CompanyFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `Company`."""
    orderBy: [CompaniesOrderBy!] = [PRIMARY_KEY_ASC]
  ): CompaniesConnection
  company(id: UUID!): Company
  companyByUserId(userId: UUID!): Company

  """Reads and enables pagination through a set of `CompanyCategory`."""
  companyCategories(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CompanyCategoryCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: CompanyCategoryFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `CompanyCategory`."""
    orderBy: [CompanyCategoriesOrderBy!] = [PRIMARY_KEY_ASC]
  ): CompanyCategoriesConnection
  companyCategory(id: UUID!): CompanyCategory
  companyCategoryByCompanyId(companyId: UUID!): CompanyCategory
  currentSessionId: UUID
  currentUser: User
  currentUserId: UUID
  currentUserIsAdmin: Boolean

  """
  Exposes the root query type nested one level down. This is helpful for Relay 1
  which can only query top level fields if they are in a particular form.
  """
  query: Query!
  service(id: UUID!): Service

  """Reads and enables pagination through a set of `Service`."""
  services(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ServiceCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: ServiceFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `Service`."""
    orderBy: [ServicesOrderBy!] = [PRIMARY_KEY_ASC]
  ): ServicesConnection
  user(id: UUID!): User

  """Reads and enables pagination through a set of `User`."""
  users(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: UserCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: UserFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `User`."""
    orderBy: [UsersOrderBy!] = [PRIMARY_KEY_ASC]
  ): UsersConnection
}

input RegisterCompanyInput {
  address: String!
  categoryId: String!
  companyName: String!
  contactNumber: String!
  description: String
  email: String!
  name: String!
  password: String!
  shopClose: String!
  shopOpen: String!
}

type RegisterCompanyPayload {
  company: Company!
  token: String!
}

input RegisterInput {
  email: String!
  name: String
  password: String!
}

type RegisterPayload {
  token: String!
  user: User!
}

"""All input for the `resetPassword` mutation."""
input ResetPasswordInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  newPassword: String!
  resetToken: String!
  userId: UUID!
}

"""The output of our `resetPassword` mutation."""
type ResetPasswordPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
  success: Boolean
}

type Service {
  """Reads and enables pagination through a set of `Address`."""
  addressesByBookingServiceIdAndAddressId(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: AddressCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: AddressFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `Address`."""
    orderBy: [AddressesOrderBy!] = [PRIMARY_KEY_ASC]
  ): ServiceAddressesByBookingServiceIdAndAddressIdManyToManyConnection!

  """Reads and enables pagination through a set of `Availability`."""
  availabilitiesByBookingServiceIdAndAvailabilityId(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: AvailabilityCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: AvailabilityFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `Availability`."""
    orderBy: [AvailabilitiesOrderBy!] = [PRIMARY_KEY_ASC]
  ): ServiceAvailabilitiesByBookingServiceIdAndAvailabilityIdManyToManyConnection!

  """Reads and enables pagination through a set of `Booking`."""
  bookings(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: BookingCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: BookingFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `Booking`."""
    orderBy: [BookingsOrderBy!] = [PRIMARY_KEY_ASC]
  ): BookingsConnection!

  """Reads a single `Category` that is related to this `Service`."""
  category: Category
  categoryId: UUID!

  """Reads a single `Company` that is related to this `Service`."""
  company: Company
  companyId: UUID!
  createdAt: Datetime!
  description: String!
  id: UUID!
  name: String!
  price: Int!
  updatedAt: Datetime!

  """Reads and enables pagination through a set of `User`."""
  usersByBookingServiceIdAndUserId(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: UserCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: UserFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `User`."""
    orderBy: [UsersOrderBy!] = [PRIMARY_KEY_ASC]
  ): ServiceUsersByBookingServiceIdAndUserIdManyToManyConnection!
}

"""A connection to a list of `Address` values, with data from `Booking`."""
type ServiceAddressesByBookingServiceIdAndAddressIdManyToManyConnection {
  """
  A list of edges which contains the `Address`, info from the `Booking`, and the cursor to aid in pagination.
  """
  edges: [ServiceAddressesByBookingServiceIdAndAddressIdManyToManyEdge!]!

  """A list of `Address` objects."""
  nodes: [Address!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Address` you could get from the connection."""
  totalCount: Int!
}

"""A `Address` edge in the connection, with data from `Booking`."""
type ServiceAddressesByBookingServiceIdAndAddressIdManyToManyEdge {
  """Reads and enables pagination through a set of `Booking`."""
  bookings(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: BookingCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: BookingFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `Booking`."""
    orderBy: [BookingsOrderBy!] = [PRIMARY_KEY_ASC]
  ): BookingsConnection!

  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Address` at the end of the edge."""
  node: Address!
}

"""
A connection to a list of `Availability` values, with data from `Booking`.
"""
type ServiceAvailabilitiesByBookingServiceIdAndAvailabilityIdManyToManyConnection {
  """
  A list of edges which contains the `Availability`, info from the `Booking`, and the cursor to aid in pagination.
  """
  edges: [ServiceAvailabilitiesByBookingServiceIdAndAvailabilityIdManyToManyEdge!]!

  """A list of `Availability` objects."""
  nodes: [Availability!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Availability` you could get from the connection."""
  totalCount: Int!
}

"""A `Availability` edge in the connection, with data from `Booking`."""
type ServiceAvailabilitiesByBookingServiceIdAndAvailabilityIdManyToManyEdge {
  """Reads and enables pagination through a set of `Booking`."""
  bookings(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: BookingCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: BookingFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `Booking`."""
    orderBy: [BookingsOrderBy!] = [PRIMARY_KEY_ASC]
  ): BookingsConnection!

  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Availability` at the end of the edge."""
  node: Availability!
}

"""
A condition to be used against `Service` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input ServiceCondition {
  """Checks for equality with the object’s `categoryId` field."""
  categoryId: UUID

  """Checks for equality with the object’s `companyId` field."""
  companyId: UUID

  """Checks for equality with the object’s `id` field."""
  id: UUID

  """Checks for equality with the object’s `name` field."""
  name: String
}

"""
A filter to be used against `Service` object types. All fields are combined with a logical ‘and.’
"""
input ServiceFilter {
  """Checks for all expressions in this list."""
  and: [ServiceFilter!]

  """Filter by the object’s `bookings` relation."""
  bookings: ServiceToManyBookingFilter

  """Some related `bookings` exist."""
  bookingsExist: Boolean

  """Filter by the object’s `category` relation."""
  category: CategoryFilter

  """Filter by the object’s `categoryId` field."""
  categoryId: UUIDFilter

  """Filter by the object’s `company` relation."""
  company: CompanyFilter

  """Filter by the object’s `companyId` field."""
  companyId: UUIDFilter

  """Filter by the object’s `id` field."""
  id: UUIDFilter

  """Filter by the object’s `name` field."""
  name: StringFilter

  """Negates the expression."""
  not: ServiceFilter

  """Checks for any expressions in this list."""
  or: [ServiceFilter!]
}

"""An input for mutations affecting `Service`"""
input ServiceInput {
  bookingsUsingId: BookingsServiceIdFkeyInverseInput
  categoryId: UUID
  categoryToCategoryId: ServicesCategoryIdFkeyInput
  companyId: UUID
  companyToCompanyId: ServicesCompanyIdFkeyInput
  description: String!
  name: String!
  price: Int!
}

"""The fields on `service` to look up the row to update."""
input ServiceOnBookingForBookingsServiceIdFkeyUsingServicesPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `service` being updated.
  """
  patch: updateServiceOnBookingForBookingsServiceIdFkeyPatch!
}

"""The fields on `service` to look up the row to update."""
input ServiceOnServiceForServicesCategoryIdFkeyUsingServicesPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `service` being updated.
  """
  patch: updateServiceOnServiceForServicesCategoryIdFkeyPatch!
}

"""The fields on `service` to look up the row to update."""
input ServiceOnServiceForServicesCompanyIdFkeyUsingServicesPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `service` being updated.
  """
  patch: updateServiceOnServiceForServicesCompanyIdFkeyPatch!
}

"""
Represents an update to a `Service`. Fields that are set will be updated.
"""
input ServicePatch {
  bookingsUsingId: BookingsServiceIdFkeyInverseInput
  categoryId: UUID
  categoryToCategoryId: ServicesCategoryIdFkeyInput
  companyId: UUID
  companyToCompanyId: ServicesCompanyIdFkeyInput
  description: String
  name: String
  price: Int
}

"""The fields on `service` to look up the row to connect."""
input ServiceServicesPkeyConnect {
  id: UUID!
}

"""The fields on `service` to look up the row to delete."""
input ServiceServicesPkeyDelete {
  id: UUID!
}

"""
A filter to be used against many `Booking` object types. All fields are combined with a logical ‘and.’
"""
input ServiceToManyBookingFilter {
  """
  Every related `Booking` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: BookingFilter

  """
  No related `Booking` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: BookingFilter

  """
  Some related `Booking` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: BookingFilter
}

"""A connection to a list of `User` values, with data from `Booking`."""
type ServiceUsersByBookingServiceIdAndUserIdManyToManyConnection {
  """
  A list of edges which contains the `User`, info from the `Booking`, and the cursor to aid in pagination.
  """
  edges: [ServiceUsersByBookingServiceIdAndUserIdManyToManyEdge!]!

  """A list of `User` objects."""
  nodes: [User!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `User` you could get from the connection."""
  totalCount: Int!
}

"""A `User` edge in the connection, with data from `Booking`."""
type ServiceUsersByBookingServiceIdAndUserIdManyToManyEdge {
  """Reads and enables pagination through a set of `Booking`."""
  bookings(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: BookingCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: BookingFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `Booking`."""
    orderBy: [BookingsOrderBy!] = [PRIMARY_KEY_ASC]
  ): BookingsConnection!

  """A cursor for use in pagination."""
  cursor: Cursor

  """The `User` at the end of the edge."""
  node: User!
}

"""The `category` to be created by this mutation."""
input ServicesCategoryIdFkeyCategoriesCreateInput {
  categoryToParentId: CategoriesParentIdFkeyInput
  companyCategoriesUsingId: CompanyCategoriesCategoryIdFkeyInverseInput
  description: String!
  name: String!
  parentId: UUID
  servicesUsingId: ServicesCategoryIdFkeyInverseInput
  slug: String!
}

"""
Input for the nested mutation of `category` in the `ServiceInput` mutation.
"""
input ServicesCategoryIdFkeyInput {
  """
  The primary key(s) for `category` for the far side of the relationship.
  """
  connectById: CategoryCategoriesPkeyConnect

  """
  The primary key(s) for `category` for the far side of the relationship.
  """
  connectByName: CategoryCategoriesNameKeyConnect

  """
  The primary key(s) for `category` for the far side of the relationship.
  """
  connectBySlug: CategoryCategoriesSlugKeyConnect

  """
  A `CategoryInput` object that will be created and connected to this object.
  """
  create: ServicesCategoryIdFkeyCategoriesCreateInput

  """
  The primary key(s) for `category` for the far side of the relationship.
  """
  deleteById: CategoryCategoriesPkeyDelete

  """
  The primary key(s) for `category` for the far side of the relationship.
  """
  deleteByName: CategoryCategoriesNameKeyDelete

  """
  The primary key(s) for `category` for the far side of the relationship.
  """
  deleteBySlug: CategoryCategoriesSlugKeyDelete

  """
  The primary key(s) and patch data for `category` for the far side of the relationship.
  """
  updateById: CategoryOnServiceForServicesCategoryIdFkeyUsingCategoriesPkeyUpdate

  """
  The primary key(s) and patch data for `category` for the far side of the relationship.
  """
  updateByName: CategoryOnServiceForServicesCategoryIdFkeyUsingCategoriesNameKeyUpdate

  """
  The primary key(s) and patch data for `category` for the far side of the relationship.
  """
  updateBySlug: CategoryOnServiceForServicesCategoryIdFkeyUsingCategoriesSlugKeyUpdate
}

"""
Input for the nested mutation of `service` in the `CategoryInput` mutation.
"""
input ServicesCategoryIdFkeyInverseInput {
  """The primary key(s) for `service` for the far side of the relationship."""
  connectById: [ServiceServicesPkeyConnect!]

  """
  A `ServiceInput` object that will be created and connected to this object.
  """
  create: [ServicesCategoryIdFkeyServicesCreateInput!]

  """The primary key(s) for `service` for the far side of the relationship."""
  deleteById: [ServiceServicesPkeyDelete!]

  """
  Flag indicating whether all other `service` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) and patch data for `service` for the far side of the relationship.
  """
  updateById: [ServiceOnServiceForServicesCategoryIdFkeyUsingServicesPkeyUpdate!]
}

"""The `service` to be created by this mutation."""
input ServicesCategoryIdFkeyServicesCreateInput {
  bookingsUsingId: BookingsServiceIdFkeyInverseInput
  categoryToCategoryId: ServicesCategoryIdFkeyInput
  companyId: UUID
  companyToCompanyId: ServicesCompanyIdFkeyInput
  description: String!
  name: String!
  price: Int!
}

"""The `company` to be created by this mutation."""
input ServicesCompanyIdFkeyCompaniesCreateInput {
  addressUsingId: AddressesCompanyIdFkeyInverseInput
  availabilityUsingId: AvailabilitiesCompanyIdFkeyInverseInput
  companyCategoryUsingId: CompanyCategoriesCompanyIdFkeyInverseInput
  description: String
  isVerified: Boolean
  name: String!
  servicesUsingId: ServicesCompanyIdFkeyInverseInput
  userId: UUID
  userToUserId: CompaniesUserIdFkeyInput
}

"""
Input for the nested mutation of `company` in the `ServiceInput` mutation.
"""
input ServicesCompanyIdFkeyInput {
  """The primary key(s) for `company` for the far side of the relationship."""
  connectById: CompanyCompaniesPkeyConnect

  """The primary key(s) for `company` for the far side of the relationship."""
  connectByUserId: CompanyCompaniesUserIdUniqueConnect

  """
  A `CompanyInput` object that will be created and connected to this object.
  """
  create: ServicesCompanyIdFkeyCompaniesCreateInput

  """The primary key(s) for `company` for the far side of the relationship."""
  deleteById: CompanyCompaniesPkeyDelete

  """The primary key(s) for `company` for the far side of the relationship."""
  deleteByUserId: CompanyCompaniesUserIdUniqueDelete

  """
  The primary key(s) and patch data for `company` for the far side of the relationship.
  """
  updateById: CompanyOnServiceForServicesCompanyIdFkeyUsingCompaniesPkeyUpdate

  """
  The primary key(s) and patch data for `company` for the far side of the relationship.
  """
  updateByUserId: CompanyOnServiceForServicesCompanyIdFkeyUsingCompaniesUserIdUniqueUpdate
}

"""
Input for the nested mutation of `service` in the `CompanyInput` mutation.
"""
input ServicesCompanyIdFkeyInverseInput {
  """The primary key(s) for `service` for the far side of the relationship."""
  connectById: [ServiceServicesPkeyConnect!]

  """
  A `ServiceInput` object that will be created and connected to this object.
  """
  create: [ServicesCompanyIdFkeyServicesCreateInput!]

  """The primary key(s) for `service` for the far side of the relationship."""
  deleteById: [ServiceServicesPkeyDelete!]

  """
  Flag indicating whether all other `service` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) and patch data for `service` for the far side of the relationship.
  """
  updateById: [ServiceOnServiceForServicesCompanyIdFkeyUsingServicesPkeyUpdate!]
}

"""The `service` to be created by this mutation."""
input ServicesCompanyIdFkeyServicesCreateInput {
  bookingsUsingId: BookingsServiceIdFkeyInverseInput
  categoryId: UUID
  categoryToCategoryId: ServicesCategoryIdFkeyInput
  companyToCompanyId: ServicesCompanyIdFkeyInput
  description: String!
  name: String!
  price: Int!
}

"""A connection to a list of `Service` values."""
type ServicesConnection {
  """
  A list of edges which contains the `Service` and cursor to aid in pagination.
  """
  edges: [ServicesEdge!]!

  """A list of `Service` objects."""
  nodes: [Service!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Service` you could get from the connection."""
  totalCount: Int!
}

"""A `Service` edge in the connection."""
type ServicesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Service` at the end of the edge."""
  node: Service!
}

"""Methods to use when ordering `Service`."""
enum ServicesOrderBy {
  CATEGORY_ID_ASC
  CATEGORY_ID_DESC
  COMPANY_ID_ASC
  COMPANY_ID_DESC
  ID_ASC
  ID_DESC
  NAME_ASC
  NAME_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A filter to be used against String fields. All fields are combined with a logical ‘and.’
"""
input StringFilter {
  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: String

  """
  Not equal to the specified value, treating null like an ordinary value (case-insensitive).
  """
  distinctFromInsensitive: String

  """Ends with the specified string (case-sensitive)."""
  endsWith: String

  """Ends with the specified string (case-insensitive)."""
  endsWithInsensitive: String

  """Equal to the specified value."""
  equalTo: String

  """Equal to the specified value (case-insensitive)."""
  equalToInsensitive: String

  """Greater than the specified value."""
  greaterThan: String

  """Greater than the specified value (case-insensitive)."""
  greaterThanInsensitive: String

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: String

  """Greater than or equal to the specified value (case-insensitive)."""
  greaterThanOrEqualToInsensitive: String

  """Included in the specified list."""
  in: [String!]

  """Included in the specified list (case-insensitive)."""
  inInsensitive: [String!]

  """Contains the specified string (case-sensitive)."""
  includes: String

  """Contains the specified string (case-insensitive)."""
  includesInsensitive: String

  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """Less than the specified value."""
  lessThan: String

  """Less than the specified value (case-insensitive)."""
  lessThanInsensitive: String

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: String

  """Less than or equal to the specified value (case-insensitive)."""
  lessThanOrEqualToInsensitive: String

  """
  Matches the specified pattern (case-sensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters.
  """
  like: String

  """
  Matches the specified pattern (case-insensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters.
  """
  likeInsensitive: String

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: String

  """
  Equal to the specified value, treating null like an ordinary value (case-insensitive).
  """
  notDistinctFromInsensitive: String

  """Does not end with the specified string (case-sensitive)."""
  notEndsWith: String

  """Does not end with the specified string (case-insensitive)."""
  notEndsWithInsensitive: String

  """Not equal to the specified value."""
  notEqualTo: String

  """Not equal to the specified value (case-insensitive)."""
  notEqualToInsensitive: String

  """Not included in the specified list."""
  notIn: [String!]

  """Not included in the specified list (case-insensitive)."""
  notInInsensitive: [String!]

  """Does not contain the specified string (case-sensitive)."""
  notIncludes: String

  """Does not contain the specified string (case-insensitive)."""
  notIncludesInsensitive: String

  """
  Does not match the specified pattern (case-sensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters.
  """
  notLike: String

  """
  Does not match the specified pattern (case-insensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters.
  """
  notLikeInsensitive: String

  """Does not start with the specified string (case-sensitive)."""
  notStartsWith: String

  """Does not start with the specified string (case-insensitive)."""
  notStartsWithInsensitive: String

  """Starts with the specified string (case-sensitive)."""
  startsWith: String

  """Starts with the specified string (case-insensitive)."""
  startsWithInsensitive: String
}

"""
The exact time of day, does not include the date. May or may not have a timezone offset.
"""
scalar Time

"""
A universally unique identifier as defined by [RFC 4122](https://tools.ietf.org/html/rfc4122).
"""
scalar UUID

"""
A filter to be used against UUID fields. All fields are combined with a logical ‘and.’
"""
input UUIDFilter {
  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: UUID

  """Equal to the specified value."""
  equalTo: UUID

  """Greater than the specified value."""
  greaterThan: UUID

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: UUID

  """Included in the specified list."""
  in: [UUID!]

  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """Less than the specified value."""
  lessThan: UUID

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: UUID

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: UUID

  """Not equal to the specified value."""
  notEqualTo: UUID

  """Not included in the specified list."""
  notIn: [UUID!]
}

"""All input for the `updateAddressByCompanyId` mutation."""
input UpdateAddressByCompanyIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  companyId: UUID!

  """
  An object where the defined keys will be set on the `Address` being updated.
  """
  patch: AddressPatch!
}

"""All input for the `updateAddress` mutation."""
input UpdateAddressInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: UUID!

  """
  An object where the defined keys will be set on the `Address` being updated.
  """
  patch: AddressPatch!
}

"""The output of our update `Address` mutation."""
type UpdateAddressPayload {
  """The `Address` that was updated by this mutation."""
  address: Address

  """An edge for our `Address`. May be used by Relay 1."""
  addressEdge(
    """The method to use when ordering `Address`."""
    orderBy: [AddressesOrderBy!] = [PRIMARY_KEY_ASC]
  ): AddressesEdge

  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """Reads a single `Company` that is related to this `Address`."""
  company: Company

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `Address`."""
  user: User
}

"""All input for the `updateAvailabilityByCompanyId` mutation."""
input UpdateAvailabilityByCompanyIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  companyId: UUID!

  """
  An object where the defined keys will be set on the `Availability` being updated.
  """
  patch: AvailabilityPatch!
}

"""All input for the `updateAvailability` mutation."""
input UpdateAvailabilityInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: UUID!

  """
  An object where the defined keys will be set on the `Availability` being updated.
  """
  patch: AvailabilityPatch!
}

"""The output of our update `Availability` mutation."""
type UpdateAvailabilityPayload {
  """The `Availability` that was updated by this mutation."""
  availability: Availability

  """An edge for our `Availability`. May be used by Relay 1."""
  availabilityEdge(
    """The method to use when ordering `Availability`."""
    orderBy: [AvailabilitiesOrderBy!] = [PRIMARY_KEY_ASC]
  ): AvailabilitiesEdge

  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """Reads a single `Company` that is related to this `Availability`."""
  company: Company

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the `updateBooking` mutation."""
input UpdateBookingInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: UUID!

  """
  An object where the defined keys will be set on the `Booking` being updated.
  """
  patch: BookingPatch!
}

"""The output of our update `Booking` mutation."""
type UpdateBookingPayload {
  """Reads a single `Address` that is related to this `Booking`."""
  address: Address

  """Reads a single `Availability` that is related to this `Booking`."""
  availability: Availability

  """The `Booking` that was updated by this mutation."""
  booking: Booking

  """An edge for our `Booking`. May be used by Relay 1."""
  bookingEdge(
    """The method to use when ordering `Booking`."""
    orderBy: [BookingsOrderBy!] = [PRIMARY_KEY_ASC]
  ): BookingsEdge

  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Service` that is related to this `Booking`."""
  service: Service

  """Reads a single `User` that is related to this `Booking`."""
  user: User
}

"""All input for the `updateCategoryByName` mutation."""
input UpdateCategoryByNameInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  name: String!

  """
  An object where the defined keys will be set on the `Category` being updated.
  """
  patch: CategoryPatch!
}

"""All input for the `updateCategoryBySlug` mutation."""
input UpdateCategoryBySlugInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Category` being updated.
  """
  patch: CategoryPatch!
  slug: String!
}

"""All input for the `updateCategory` mutation."""
input UpdateCategoryInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: UUID!

  """
  An object where the defined keys will be set on the `Category` being updated.
  """
  patch: CategoryPatch!
}

"""The output of our update `Category` mutation."""
type UpdateCategoryPayload {
  """The `Category` that was updated by this mutation."""
  category: Category

  """An edge for our `Category`. May be used by Relay 1."""
  categoryEdge(
    """The method to use when ordering `Category`."""
    orderBy: [CategoriesOrderBy!] = [PRIMARY_KEY_ASC]
  ): CategoriesEdge

  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """Reads a single `Category` that is related to this `Category`."""
  parent: Category

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the `updateCompanyByUserId` mutation."""
input UpdateCompanyByUserIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Company` being updated.
  """
  patch: CompanyPatch!
  userId: UUID!
}

"""All input for the `updateCompanyCategoryByCompanyId` mutation."""
input UpdateCompanyCategoryByCompanyIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  companyId: UUID!

  """
  An object where the defined keys will be set on the `CompanyCategory` being updated.
  """
  patch: CompanyCategoryPatch!
}

"""All input for the `updateCompanyCategory` mutation."""
input UpdateCompanyCategoryInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: UUID!

  """
  An object where the defined keys will be set on the `CompanyCategory` being updated.
  """
  patch: CompanyCategoryPatch!
}

"""The output of our update `CompanyCategory` mutation."""
type UpdateCompanyCategoryPayload {
  """Reads a single `Category` that is related to this `CompanyCategory`."""
  category: Category

  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """Reads a single `Company` that is related to this `CompanyCategory`."""
  company: Company

  """The `CompanyCategory` that was updated by this mutation."""
  companyCategory: CompanyCategory

  """An edge for our `CompanyCategory`. May be used by Relay 1."""
  companyCategoryEdge(
    """The method to use when ordering `CompanyCategory`."""
    orderBy: [CompanyCategoriesOrderBy!] = [PRIMARY_KEY_ASC]
  ): CompanyCategoriesEdge

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the `updateCompany` mutation."""
input UpdateCompanyInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: UUID!

  """
  An object where the defined keys will be set on the `Company` being updated.
  """
  patch: CompanyPatch!
}

"""The output of our update `Company` mutation."""
type UpdateCompanyPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Company` that was updated by this mutation."""
  company: Company

  """An edge for our `Company`. May be used by Relay 1."""
  companyEdge(
    """The method to use when ordering `Company`."""
    orderBy: [CompaniesOrderBy!] = [PRIMARY_KEY_ASC]
  ): CompaniesEdge

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `Company`."""
  user: User
}

"""All input for the `updateService` mutation."""
input UpdateServiceInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: UUID!

  """
  An object where the defined keys will be set on the `Service` being updated.
  """
  patch: ServicePatch!
}

"""The output of our update `Service` mutation."""
type UpdateServicePayload {
  """Reads a single `Category` that is related to this `Service`."""
  category: Category

  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """Reads a single `Company` that is related to this `Service`."""
  company: Company

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """The `Service` that was updated by this mutation."""
  service: Service

  """An edge for our `Service`. May be used by Relay 1."""
  serviceEdge(
    """The method to use when ordering `Service`."""
    orderBy: [ServicesOrderBy!] = [PRIMARY_KEY_ASC]
  ): ServicesEdge
}

"""All input for the `updateUser` mutation."""
input UpdateUserInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: UUID!

  """
  An object where the defined keys will be set on the `User` being updated.
  """
  patch: UserPatch!
}

"""The output of our update `User` mutation."""
type UpdateUserPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """The `User` that was updated by this mutation."""
  user: User

  """An edge for our `User`. May be used by Relay 1."""
  userEdge(
    """The method to use when ordering `User`."""
    orderBy: [UsersOrderBy!] = [PRIMARY_KEY_ASC]
  ): UsersEdge
}

type User {
  """Reads and enables pagination through a set of `Address`."""
  addresses(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: AddressCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: AddressFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `Address`."""
    orderBy: [AddressesOrderBy!] = [PRIMARY_KEY_ASC]
  ): AddressesConnection!

  """Reads and enables pagination through a set of `Address`."""
  addressesByBookingUserIdAndAddressId(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: AddressCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: AddressFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `Address`."""
    orderBy: [AddressesOrderBy!] = [PRIMARY_KEY_ASC]
  ): UserAddressesByBookingUserIdAndAddressIdManyToManyConnection!

  """Reads and enables pagination through a set of `Availability`."""
  availabilitiesByBookingUserIdAndAvailabilityId(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: AvailabilityCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: AvailabilityFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `Availability`."""
    orderBy: [AvailabilitiesOrderBy!] = [PRIMARY_KEY_ASC]
  ): UserAvailabilitiesByBookingUserIdAndAvailabilityIdManyToManyConnection!

  """Reads and enables pagination through a set of `Booking`."""
  bookings(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: BookingCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: BookingFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `Booking`."""
    orderBy: [BookingsOrderBy!] = [PRIMARY_KEY_ASC]
  ): BookingsConnection!

  """Reads and enables pagination through a set of `Company`."""
  companies(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CompanyCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: CompanyFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `Company`."""
    orderBy: [CompaniesOrderBy!] = [PRIMARY_KEY_ASC]
  ): CompaniesConnection! @deprecated(reason: "Please use company instead")

  """Reads a single `Company` that is related to this `User`."""
  company: Company
  createdAt: Datetime!
  email: String!
  id: UUID!
  isAdmin: Boolean!
  isVerified: Boolean!
  name: String
  password: String

  """Reads and enables pagination through a set of `Service`."""
  servicesByBookingUserIdAndServiceId(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ServiceCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: ServiceFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `Service`."""
    orderBy: [ServicesOrderBy!] = [PRIMARY_KEY_ASC]
  ): UserServicesByBookingUserIdAndServiceIdManyToManyConnection!
  type: String!
  updatedAt: Datetime!
}

"""A connection to a list of `Address` values, with data from `Booking`."""
type UserAddressesByBookingUserIdAndAddressIdManyToManyConnection {
  """
  A list of edges which contains the `Address`, info from the `Booking`, and the cursor to aid in pagination.
  """
  edges: [UserAddressesByBookingUserIdAndAddressIdManyToManyEdge!]!

  """A list of `Address` objects."""
  nodes: [Address!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Address` you could get from the connection."""
  totalCount: Int!
}

"""A `Address` edge in the connection, with data from `Booking`."""
type UserAddressesByBookingUserIdAndAddressIdManyToManyEdge {
  """Reads and enables pagination through a set of `Booking`."""
  bookings(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: BookingCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: BookingFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `Booking`."""
    orderBy: [BookingsOrderBy!] = [PRIMARY_KEY_ASC]
  ): BookingsConnection!

  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Address` at the end of the edge."""
  node: Address!
}

"""
A connection to a list of `Availability` values, with data from `Booking`.
"""
type UserAvailabilitiesByBookingUserIdAndAvailabilityIdManyToManyConnection {
  """
  A list of edges which contains the `Availability`, info from the `Booking`, and the cursor to aid in pagination.
  """
  edges: [UserAvailabilitiesByBookingUserIdAndAvailabilityIdManyToManyEdge!]!

  """A list of `Availability` objects."""
  nodes: [Availability!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Availability` you could get from the connection."""
  totalCount: Int!
}

"""A `Availability` edge in the connection, with data from `Booking`."""
type UserAvailabilitiesByBookingUserIdAndAvailabilityIdManyToManyEdge {
  """Reads and enables pagination through a set of `Booking`."""
  bookings(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: BookingCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: BookingFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `Booking`."""
    orderBy: [BookingsOrderBy!] = [PRIMARY_KEY_ASC]
  ): BookingsConnection!

  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Availability` at the end of the edge."""
  node: Availability!
}

"""
A condition to be used against `User` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input UserCondition {
  """Checks for equality with the object’s `email` field."""
  email: String

  """Checks for equality with the object’s `id` field."""
  id: UUID

  """Checks for equality with the object’s `name` field."""
  name: String
}

"""
A filter to be used against `User` object types. All fields are combined with a logical ‘and.’
"""
input UserFilter {
  """Filter by the object’s `addresses` relation."""
  addresses: UserToManyAddressFilter

  """Some related `addresses` exist."""
  addressesExist: Boolean

  """Checks for all expressions in this list."""
  and: [UserFilter!]

  """Filter by the object’s `bookings` relation."""
  bookings: UserToManyBookingFilter

  """Some related `bookings` exist."""
  bookingsExist: Boolean

  """Filter by the object’s `company` relation."""
  company: CompanyFilter

  """A related `company` exists."""
  companyExists: Boolean

  """Filter by the object’s `email` field."""
  email: StringFilter

  """Filter by the object’s `id` field."""
  id: UUIDFilter

  """Filter by the object’s `name` field."""
  name: StringFilter

  """Negates the expression."""
  not: UserFilter

  """Checks for any expressions in this list."""
  or: [UserFilter!]
}

"""An input for mutations affecting `User`"""
input UserInput {
  addressesUsingId: AddressesUserIdFkeyInverseInput
  bookingsUsingId: BookingsUserIdFkeyInverseInput
  companyUsingId: CompaniesUserIdFkeyInverseInput
  email: String!
  isAdmin: Boolean
  isVerified: Boolean
  name: String
  password: String
  type: String
}

"""The fields on `user` to look up the row to update."""
input UserOnAddressForAddressesUserIdFkeyUsingUsersPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `user` being updated.
  """
  patch: updateUserOnAddressForAddressesUserIdFkeyPatch!
}

"""The fields on `user` to look up the row to update."""
input UserOnBookingForBookingsUserIdFkeyUsingUsersPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `user` being updated.
  """
  patch: updateUserOnBookingForBookingsUserIdFkeyPatch!
}

"""The fields on `user` to look up the row to update."""
input UserOnCompanyForCompaniesUserIdFkeyUsingUsersPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `user` being updated.
  """
  patch: updateUserOnCompanyForCompaniesUserIdFkeyPatch!
}

"""Represents an update to a `User`. Fields that are set will be updated."""
input UserPatch {
  addressesUsingId: AddressesUserIdFkeyInverseInput
  bookingsUsingId: BookingsUserIdFkeyInverseInput
  companyUsingId: CompaniesUserIdFkeyInverseInput
  email: String
  isAdmin: Boolean
  isVerified: Boolean
  name: String
  password: String
  type: String
}

"""A connection to a list of `Service` values, with data from `Booking`."""
type UserServicesByBookingUserIdAndServiceIdManyToManyConnection {
  """
  A list of edges which contains the `Service`, info from the `Booking`, and the cursor to aid in pagination.
  """
  edges: [UserServicesByBookingUserIdAndServiceIdManyToManyEdge!]!

  """A list of `Service` objects."""
  nodes: [Service!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Service` you could get from the connection."""
  totalCount: Int!
}

"""A `Service` edge in the connection, with data from `Booking`."""
type UserServicesByBookingUserIdAndServiceIdManyToManyEdge {
  """Reads and enables pagination through a set of `Booking`."""
  bookings(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: BookingCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: BookingFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `Booking`."""
    orderBy: [BookingsOrderBy!] = [PRIMARY_KEY_ASC]
  ): BookingsConnection!

  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Service` at the end of the edge."""
  node: Service!
}

"""
A filter to be used against many `Address` object types. All fields are combined with a logical ‘and.’
"""
input UserToManyAddressFilter {
  """
  Every related `Address` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: AddressFilter

  """
  No related `Address` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: AddressFilter

  """
  Some related `Address` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: AddressFilter
}

"""
A filter to be used against many `Booking` object types. All fields are combined with a logical ‘and.’
"""
input UserToManyBookingFilter {
  """
  Every related `Booking` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: BookingFilter

  """
  No related `Booking` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: BookingFilter

  """
  Some related `Booking` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: BookingFilter
}

"""The fields on `user` to look up the row to connect."""
input UserUsersPkeyConnect {
  id: UUID!
}

"""The fields on `user` to look up the row to delete."""
input UserUsersPkeyDelete {
  id: UUID!
}

"""A connection to a list of `User` values."""
type UsersConnection {
  """
  A list of edges which contains the `User` and cursor to aid in pagination.
  """
  edges: [UsersEdge!]!

  """A list of `User` objects."""
  nodes: [User!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `User` you could get from the connection."""
  totalCount: Int!
}

"""A `User` edge in the connection."""
type UsersEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `User` at the end of the edge."""
  node: User!
}

"""Methods to use when ordering `User`."""
enum UsersOrderBy {
  EMAIL_ASC
  EMAIL_DESC
  ID_ASC
  ID_DESC
  NAME_ASC
  NAME_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
An object where the defined keys will be set on the `address` being updated.
"""
input updateAddressOnAddressForAddressesCompanyIdFkeyPatch {
  address: String
  bookingsUsingId: BookingsAddressIdFkeyInverseInput
  companyToCompanyId: AddressesCompanyIdFkeyInput
  contactNumber: String
  isPrimary: Boolean
  userId: UUID
  userToUserId: AddressesUserIdFkeyInput
}

"""
An object where the defined keys will be set on the `address` being updated.
"""
input updateAddressOnAddressForAddressesUserIdFkeyPatch {
  address: String
  bookingsUsingId: BookingsAddressIdFkeyInverseInput
  companyId: UUID
  companyToCompanyId: AddressesCompanyIdFkeyInput
  contactNumber: String
  isPrimary: Boolean
  userToUserId: AddressesUserIdFkeyInput
}

"""
An object where the defined keys will be set on the `address` being updated.
"""
input updateAddressOnBookingForBookingsAddressIdFkeyPatch {
  address: String
  bookingsUsingId: BookingsAddressIdFkeyInverseInput
  companyId: UUID
  companyToCompanyId: AddressesCompanyIdFkeyInput
  contactNumber: String
  isPrimary: Boolean
  userId: UUID
  userToUserId: AddressesUserIdFkeyInput
}

"""
An object where the defined keys will be set on the `availability` being updated.
"""
input updateAvailabilityOnAvailabilityForAvailabilitiesCompanyIdFkeyPatch {
  bookingsUsingId: BookingsAvailabilityIdFkeyInverseInput
  companyToCompanyId: AvailabilitiesCompanyIdFkeyInput
  endTime: Time
  startTime: Time
}

"""
An object where the defined keys will be set on the `availability` being updated.
"""
input updateAvailabilityOnBookingForBookingsAvailabilityIdFkeyPatch {
  bookingsUsingId: BookingsAvailabilityIdFkeyInverseInput
  companyId: UUID
  companyToCompanyId: AvailabilitiesCompanyIdFkeyInput
  endTime: Time
  startTime: Time
}

"""
An object where the defined keys will be set on the `booking` being updated.
"""
input updateBookingOnBookingForBookingsAddressIdFkeyPatch {
  addressToAddressId: BookingsAddressIdFkeyInput
  availabilityId: UUID
  availabilityToAvailabilityId: BookingsAvailabilityIdFkeyInput
  serviceId: UUID
  serviceToServiceId: BookingsServiceIdFkeyInput
  status: String
  userId: UUID
  userToUserId: BookingsUserIdFkeyInput
}

"""
An object where the defined keys will be set on the `booking` being updated.
"""
input updateBookingOnBookingForBookingsAvailabilityIdFkeyPatch {
  addressId: UUID
  addressToAddressId: BookingsAddressIdFkeyInput
  availabilityToAvailabilityId: BookingsAvailabilityIdFkeyInput
  serviceId: UUID
  serviceToServiceId: BookingsServiceIdFkeyInput
  status: String
  userId: UUID
  userToUserId: BookingsUserIdFkeyInput
}

"""
An object where the defined keys will be set on the `booking` being updated.
"""
input updateBookingOnBookingForBookingsServiceIdFkeyPatch {
  addressId: UUID
  addressToAddressId: BookingsAddressIdFkeyInput
  availabilityId: UUID
  availabilityToAvailabilityId: BookingsAvailabilityIdFkeyInput
  serviceToServiceId: BookingsServiceIdFkeyInput
  status: String
  userId: UUID
  userToUserId: BookingsUserIdFkeyInput
}

"""
An object where the defined keys will be set on the `booking` being updated.
"""
input updateBookingOnBookingForBookingsUserIdFkeyPatch {
  addressId: UUID
  addressToAddressId: BookingsAddressIdFkeyInput
  availabilityId: UUID
  availabilityToAvailabilityId: BookingsAvailabilityIdFkeyInput
  serviceId: UUID
  serviceToServiceId: BookingsServiceIdFkeyInput
  status: String
  userToUserId: BookingsUserIdFkeyInput
}

"""
An object where the defined keys will be set on the `category` being updated.
"""
input updateCategoryOnCategoryForCategoriesParentIdFkeyPatch {
  categoryToParentId: CategoriesParentIdFkeyInput
  companyCategoriesUsingId: CompanyCategoriesCategoryIdFkeyInverseInput
  description: String
  name: String
  servicesUsingId: ServicesCategoryIdFkeyInverseInput
  slug: String
}

"""
An object where the defined keys will be set on the `category` being updated.
"""
input updateCategoryOnCompanyCategoryForCompanyCategoriesCategoryIdFkeyPatch {
  categoryToParentId: CategoriesParentIdFkeyInput
  companyCategoriesUsingId: CompanyCategoriesCategoryIdFkeyInverseInput
  description: String
  name: String
  parentId: UUID
  servicesUsingId: ServicesCategoryIdFkeyInverseInput
  slug: String
}

"""
An object where the defined keys will be set on the `category` being updated.
"""
input updateCategoryOnServiceForServicesCategoryIdFkeyPatch {
  categoryToParentId: CategoriesParentIdFkeyInput
  companyCategoriesUsingId: CompanyCategoriesCategoryIdFkeyInverseInput
  description: String
  name: String
  parentId: UUID
  servicesUsingId: ServicesCategoryIdFkeyInverseInput
  slug: String
}

"""
An object where the defined keys will be set on the `companyCategory` being updated.
"""
input updateCompanyCategoryOnCompanyCategoryForCompanyCategoriesCategoryIdFkeyPatch {
  categoryToCategoryId: CompanyCategoriesCategoryIdFkeyInput
  companyId: UUID
  companyToCompanyId: CompanyCategoriesCompanyIdFkeyInput
}

"""
An object where the defined keys will be set on the `companyCategory` being updated.
"""
input updateCompanyCategoryOnCompanyCategoryForCompanyCategoriesCompanyIdFkeyPatch {
  categoryId: UUID
  categoryToCategoryId: CompanyCategoriesCategoryIdFkeyInput
  companyToCompanyId: CompanyCategoriesCompanyIdFkeyInput
}

"""
An object where the defined keys will be set on the `company` being updated.
"""
input updateCompanyOnAddressForAddressesCompanyIdFkeyPatch {
  addressUsingId: AddressesCompanyIdFkeyInverseInput
  availabilityUsingId: AvailabilitiesCompanyIdFkeyInverseInput
  companyCategoryUsingId: CompanyCategoriesCompanyIdFkeyInverseInput
  description: String
  isVerified: Boolean
  name: String
  servicesUsingId: ServicesCompanyIdFkeyInverseInput
  userId: UUID
  userToUserId: CompaniesUserIdFkeyInput
}

"""
An object where the defined keys will be set on the `company` being updated.
"""
input updateCompanyOnAvailabilityForAvailabilitiesCompanyIdFkeyPatch {
  addressUsingId: AddressesCompanyIdFkeyInverseInput
  availabilityUsingId: AvailabilitiesCompanyIdFkeyInverseInput
  companyCategoryUsingId: CompanyCategoriesCompanyIdFkeyInverseInput
  description: String
  isVerified: Boolean
  name: String
  servicesUsingId: ServicesCompanyIdFkeyInverseInput
  userId: UUID
  userToUserId: CompaniesUserIdFkeyInput
}

"""
An object where the defined keys will be set on the `company` being updated.
"""
input updateCompanyOnCompanyCategoryForCompanyCategoriesCompanyIdFkeyPatch {
  addressUsingId: AddressesCompanyIdFkeyInverseInput
  availabilityUsingId: AvailabilitiesCompanyIdFkeyInverseInput
  companyCategoryUsingId: CompanyCategoriesCompanyIdFkeyInverseInput
  description: String
  isVerified: Boolean
  name: String
  servicesUsingId: ServicesCompanyIdFkeyInverseInput
  userId: UUID
  userToUserId: CompaniesUserIdFkeyInput
}

"""
An object where the defined keys will be set on the `company` being updated.
"""
input updateCompanyOnCompanyForCompaniesUserIdFkeyPatch {
  addressUsingId: AddressesCompanyIdFkeyInverseInput
  availabilityUsingId: AvailabilitiesCompanyIdFkeyInverseInput
  companyCategoryUsingId: CompanyCategoriesCompanyIdFkeyInverseInput
  description: String
  isVerified: Boolean
  name: String
  servicesUsingId: ServicesCompanyIdFkeyInverseInput
  userToUserId: CompaniesUserIdFkeyInput
}

"""
An object where the defined keys will be set on the `company` being updated.
"""
input updateCompanyOnServiceForServicesCompanyIdFkeyPatch {
  addressUsingId: AddressesCompanyIdFkeyInverseInput
  availabilityUsingId: AvailabilitiesCompanyIdFkeyInverseInput
  companyCategoryUsingId: CompanyCategoriesCompanyIdFkeyInverseInput
  description: String
  isVerified: Boolean
  name: String
  servicesUsingId: ServicesCompanyIdFkeyInverseInput
  userId: UUID
  userToUserId: CompaniesUserIdFkeyInput
}

"""
An object where the defined keys will be set on the `service` being updated.
"""
input updateServiceOnBookingForBookingsServiceIdFkeyPatch {
  bookingsUsingId: BookingsServiceIdFkeyInverseInput
  categoryId: UUID
  categoryToCategoryId: ServicesCategoryIdFkeyInput
  companyId: UUID
  companyToCompanyId: ServicesCompanyIdFkeyInput
  description: String
  name: String
  price: Int
}

"""
An object where the defined keys will be set on the `service` being updated.
"""
input updateServiceOnServiceForServicesCategoryIdFkeyPatch {
  bookingsUsingId: BookingsServiceIdFkeyInverseInput
  categoryToCategoryId: ServicesCategoryIdFkeyInput
  companyId: UUID
  companyToCompanyId: ServicesCompanyIdFkeyInput
  description: String
  name: String
  price: Int
}

"""
An object where the defined keys will be set on the `service` being updated.
"""
input updateServiceOnServiceForServicesCompanyIdFkeyPatch {
  bookingsUsingId: BookingsServiceIdFkeyInverseInput
  categoryId: UUID
  categoryToCategoryId: ServicesCategoryIdFkeyInput
  companyToCompanyId: ServicesCompanyIdFkeyInput
  description: String
  name: String
  price: Int
}

"""
An object where the defined keys will be set on the `user` being updated.
"""
input updateUserOnAddressForAddressesUserIdFkeyPatch {
  addressesUsingId: AddressesUserIdFkeyInverseInput
  bookingsUsingId: BookingsUserIdFkeyInverseInput
  companyUsingId: CompaniesUserIdFkeyInverseInput
  email: String
  isAdmin: Boolean
  isVerified: Boolean
  name: String
  password: String
  type: String
}

"""
An object where the defined keys will be set on the `user` being updated.
"""
input updateUserOnBookingForBookingsUserIdFkeyPatch {
  addressesUsingId: AddressesUserIdFkeyInverseInput
  bookingsUsingId: BookingsUserIdFkeyInverseInput
  companyUsingId: CompaniesUserIdFkeyInverseInput
  email: String
  isAdmin: Boolean
  isVerified: Boolean
  name: String
  password: String
  type: String
}

"""
An object where the defined keys will be set on the `user` being updated.
"""
input updateUserOnCompanyForCompaniesUserIdFkeyPatch {
  addressesUsingId: AddressesUserIdFkeyInverseInput
  bookingsUsingId: BookingsUserIdFkeyInverseInput
  companyUsingId: CompaniesUserIdFkeyInverseInput
  email: String
  isAdmin: Boolean
  isVerified: Boolean
  name: String
  password: String
  type: String
}
